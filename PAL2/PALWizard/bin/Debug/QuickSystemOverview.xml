<?xml version="1.0"?>
<PAL PALVERSION="2.0" NAME="Quick System Overview" DESCRIPTION="Quick base operating system performance analysis. Use this for a high level analysis. This threshold file does not contain the Process object to help reduce overhead." CONTENTOWNERS="Clint Huffman" FEEDBACKEMAILADDRESS="clinth@microsoft.com" VERSION="1.9" LANGUAGE="English" LANGUAGECODE="en">
  <QUESTION QUESTIONVARNAME="OS" DATATYPE="options" DEFAULTVALUE="Windows Server" OPTIONS="Windows Server,Windows Server 2016,Windows 10 32-bit,Windows 10 64-bit,Windows Server 2012 R2,Windows Server 2012,Windows 8 32-bit,Windows 8 64-bit,Windows 7 32-bit,Windows 7 64-bit,Windows Server 2008 R2,Windows Server 2008 32-bit,Windows Server 2008 64-bit,Windows Vista 32-bit,Windows Vista 64-bit,Windows Server 2003 32-bit,Windows Server 2003 64-bit,Windows XP 32-bit,Windows XP 64-bit">What operating system and architecture?                           Use the following Powershell command to get the value:     gwmi Win32_OperatingSystem | Select OSArchitecture, Caption</QUESTION>
  <QUESTION QUESTIONVARNAME="PhysicalMemory" DATATYPE="string" DEFAULTVALUE="16">How much physical memory (RAM) in GB?                          Use the following Powershell command to get the value: gwmi Win32_ComputerSystem | % {$_.TotalPhysicalMemory /1GB}</QUESTION>
  <QUESTION QUESTIONVARNAME="UserVa" DATATYPE="string" DEFAULTVALUE="2048">If *32-bit*, what is the size of the user mode virtual address space in MB?                                                                     This is ignored if 64-bit. UserVa is the value of the /USERVA boot.ini switch commonly associated with the /3GB switch or it is the value of the IncreaseUserVa setting on Windows Vista and Windows Server 2008 and later. Use the following Powershell command to get the value:                                                                                   gwmi Win32_OperatingSystem | % {$_.MaxProcessMemorySize / 1MB}</QUESTION>
  <ANALYSIS NAME="Memory Available MBytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Available MBytes" ID="{798f674d-5173-4115-a051-4589dde82bea}">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Available MBytes" EXPRESSIONPATH="\Memory\Available MBytes" COLLECTIONVARNAME="CollectionOfAvailableMBytes" DATATYPE="Integer" />
    <CHART CHARTTITLE="\Memory\Available MBytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Available MBytes" CHARTLABELS="instance" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[$TenPercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1024) * 0.10
$FivePercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1024) * 0.05
If ($FivePercentOfPhysicalMemory -lt 64)
{$FivePercentOfPhysicalMemory = 64
}
StaticChartThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -MinThreshold $FivePercentOfPhysicalMemory -MaxThreshold $TenPercentOfPhysicalMemory -IsOperatorGreaterThan $False -UseMaxValue $False
]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[$FivePercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1024) * 0.05
If ($FivePercentOfPhysicalMemory -lt 64)
{$FivePercentOfPhysicalMemory = 64
}
StaticChartThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -MinThreshold 0.001 -MaxThreshold $FivePercentOfPhysicalMemory -IsOperatorGreaterThan $False -UseMaxValue $True
]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Less than 10 percent of RAM is available" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
$TenPercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1024) * 0.10

StaticThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -Operator 'lt' -Threshold $TenPercentOfPhysicalMemory
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 5 percent of RAM is available or less than 64 MB of RAM is available" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[$FivePercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1024) * 0.05
If ($FivePercentOfPhysicalMemory -lt 64)
{
	$FivePercentOfPhysicalMemory = 64
}
StaticThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -Operator 'lt' -Threshold $FivePercentOfPhysicalMemory
        ]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Available MBytes is the amount of physical RAM, in megabytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists. If this counter is low, then the computer is running low on physical memory (RAM).<BR>
This analysis will alert a Warning if this counter's value is less than 10% of the physical memory installed and will alert a critical if this counter's value is less than 100 MB.
<br>
<br>
<B>References:</B>
<UL>
<LI><A HREF="http://social.technet.microsoft.com/wiki/contents/articles/1514.perfguide-low-available-ram.aspx">PerfGuide: Low Available RAM</A></LI>
<LI>Chapter 8: Physical Memory of the <A HREF="http://www.amazon.com/Windows-Performance-Analysis-Field-Guide/dp/0124167012/ref=sr_1_1?ie=UTF8&qid=1428215806&sr=8-1&keywords=clint+huffman">Windows Performance Analysis Field Guide</A> by Clint Huffman</LI>
</UL>
<BR>

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % Processor Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% Processor Time" ID="{cb0ff328-03e6-46e2-b1c9-aae2e23deff3}">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Processor Time" EXPRESSIONPATH="\Processor(*)\% Processor Time" COLLECTIONVARNAME="CollectionOfPercentProcessorTime" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 50% processor utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -Operator 'gt' -Threshold 50]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% processor utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -Operator 'gt' -Threshold 80]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Processor(*)\% Processor Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% Processor Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>% Processor Time</B> is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the duration of the idle thread is active in the sample interval, and subtracting that time from interval duration. This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. <B>% Processor Time</B> is the sum of <B>% User Time </B> and <B>% Privileged Time</B> unless there is hardware involvement in the form of interupts and/or DPCs.<BR>
<BR>
This analysis creates a Warning alert for utilization greater than 50% on any processor and creates a critical alert for utilization greater than 80%.<BR>
<BR>

If average processor utilization is high based on the thresholds witin this analysis, then check if it is high user mode CPU or high privileged mode. If high privileged mode CPU is suspected, then see the Privileged Mode CPU Analysis. If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See <A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A> article in the references section for more information.
      <BR>
<B>References:</B>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A></LI>
</UL>
<BR>

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % Privileged Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% Privileged Time" ID="{458b8c41-1cd4-4380-97e5-07aa279f841f}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Privileged Time" COLLECTIONVARNAME="CollectionOfProcessorPercentPrivilegedTimeAll" EXPRESSIONPATH="\Processor(*)\% Privileged Time" DATATYPE="integer" />
    <THRESHOLD NAME="More than 20% privileged (kernel) mode CPU usage" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -Operator 'gt' -Threshold 20        
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 30% privileged (kernel) mode CPU usage" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -Operator 'gt' -Threshold 30
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Processor(*)\% Privileged Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% Privileged Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -MinThreshold 20 -MaxThreshold 30 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -MinThreshold 30 -MaxThreshold 99.999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[This counter indicates the percentage of time a thread runs in privileged mode also known as kernel mode. When your application calls operating system functions (for example to perform file or network I/O or to allocate memory), these operating system functions are executed in privileged mode.<BR>
<BR>
High privileged mode CPU indicates that computer is spending too much time in system I/O versus real (user mode) work. % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.<BR>
<BR>
This analysis throws a warning alert if privileged mode CPU is consuming more than 20% of total CPU and a critical alert if consuming More than 30% of total CPU.<br>

<BR>
<B>Next steps</B><BR>
The CPU consumption might be caused by another busy resource such as network, memory, or disk I/O. High privileged mode CPU can also by caused by high amounts of Context Switches/second. See the High Context Switches/second analysis. The <A HREF="http://www.microsoft.com/whdc/system/sysperf/krview.mspx">KernRate (KrView) tool</A> can be used to profile the kernel to see what component is consuming the most kernel resources. To see more information about how KernRate can be used to analyze high priviledge mode CPU problems, see Mark Russinovich's blog entry in the references section below.<BR>
<BR>
<B>References:</B><BR>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://blogs.technet.com/markrussinovich/archive/2008/04/07/3031251.aspx">Mark's Blog : The Case of the System Process CPU Spikes</A></LI>
</UL>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface % Network Utilization" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Total/sec" ID="{2a3b7706-a244-4d0d-a0a8-33f5eddcdee7}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Total/sec" EXPRESSIONPATH="\Network Interface(*)\Bytes Total/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesTotalPerSec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Network Interface(*)\% Network Utilization" EXPRESSIONPATH="\Network Interface(*)\% Network Utilization" COLLECTIONVARNAME="CollectionOfNetworkUtilization" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfNetworkUtilization = @{}
          For ($i=0;$i -lt $CollectionOfNetworkInterfaceBytesTotalPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfNetworkInterfaceCurrentBandwidth.Count;$a++)
            {
              If ($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterInstance -eq $CollectionOfNetworkInterfaceCurrentBandwidth[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfNetworkInterfaceBytesTotalPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfNetworkUtilization = (([double]$CollectionOfNetworkInterfaceBytesTotalPerSec[$i].QuantizedAvg[$v] * 8) / [double]$CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v]) * 100
                [void] $alValues.Add($iPercentageOfNetworkUtilization)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterComputer)\$($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterObject)($($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterInstance))\% Network Utilization"
            $CollectionOfNetworkUtilization.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 30% Network Utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -Operator 'gt' -Threshold 30
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 50% Network Utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -Operator 'gt' -Threshold 50

        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="% Network Utilization" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\% Network Utilization" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ % Network Utilization doesn't exist as a normal performance counter, so this analysis uses multiplies <B>\Network Interface(*)\Bytes Total/sec</B> by 8 (to convert it to bits total/sec), divides it by <B>\Network Interface(*)\Current Bandwidth</B>, and multiplies the result by 100 to create a percentage. This analysis throws a warning alert when greater than 50 and throws a critical alert when greater than 80.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Output Queue Length" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Output Queue Length" ID="{c656eb10-a1f1-48d1-bc49-91abbb8bf4a1}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Output Queue Length" EXPRESSIONPATH="\Network Interface(*)\Output Queue Length" COLLECTIONVARNAME="CollectionOfNetworkInterfaceOutputQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 1 packet is waiting in the output queue" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -Operator 'gt' -Threshold 1
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 2 packets are waiting in the output queue" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -Operator 'gt' -Threshold 2
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Network Interface(*)\Output Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\Output Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -MinThreshold 1 -MaxThreshold 1.999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -MinThreshold 2 -MaxThreshold 2.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
  </ANALYSIS>
  <!-- % Network Utilization send and receive -->
  <ANALYSIS NAME="Network Interface % Network Utilization Sent" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Sent/sec" ID="{3f2dd3c0-3b1a-4b2b-84c0-97fd4d26c138}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Sent/sec" EXPRESSIONPATH="\Network Interface(*)\Bytes Sent/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesSentPerSec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Network Interface(*)\% Network Utilization Sent" EXPRESSIONPATH="\Network Interface(*)\% Network Utilization Sent" COLLECTIONVARNAME="CollectionOfSentNetworkUtilization" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfSentNetworkUtilization = @{}
          For ($i=0;$i -lt $CollectionOfNetworkInterfaceBytesSentPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfNetworkInterfaceCurrentBandwidth.Count;$a++)
            {
              If ($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterInstance -eq $CollectionOfNetworkInterfaceCurrentBandwidth[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfNetworkInterfaceBytesSentPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfNetworkInterfaceBytesSentPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfNetworkUtilization = (([double]$CollectionOfNetworkInterfaceBytesSentPerSec[$i].QuantizedAvg[$v] * 8) / [double]$CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v]) * 100
                [void] $alValues.Add($iPercentageOfNetworkUtilization)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterComputer)\$($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterObject)($($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterInstance))\% Network Utilization Sent"
            $CollectionOfSentNetworkUtilization.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 30% network utilization sent" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfSentNetworkUtilization -Operator 'gt' -Threshold 30
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 50% network utilization sent" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSentNetworkUtilization -Operator 'gt' -Threshold 50
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="% Network Utilization Sent" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\% Network Utilization Sent" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSentNetworkUtilization -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSentNetworkUtilization -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ % Network Utilization Sent doesn't exist as a normal performance counter, so this analysis uses multiplies <B>\Network Interface(*)\Bytes Sent/sec</B> by 8 (to convert it to bits total/sec), divides it by <B>\Network Interface(*)\Current Bandwidth</B>, and multiplies the result by 100 to create a percentage. This analysis throws a warning alert when greater than 50 and throws a critical alert when greater than 80.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface % Network Utilization Received" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Received/sec" ID="{da746e97-b1f4-42d4-b13d-88f199636989}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Received/sec" EXPRESSIONPATH="\Network Interface(*)\Bytes Received/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesReceivedPerSec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Network Interface(*)\% Network Utilization Received" EXPRESSIONPATH="\Network Interface(*)\% Network Utilization Received" COLLECTIONVARNAME="CollectionOfReceivedNetworkUtilization" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfReceivedNetworkUtilization = @{}
          For ($i=0;$i -lt $CollectionOfNetworkInterfaceBytesReceivedPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfNetworkInterfaceCurrentBandwidth.Count;$a++)
            {
              If ($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterInstance -eq $CollectionOfNetworkInterfaceCurrentBandwidth[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfNetworkUtilization = (([double]$CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].QuantizedAvg[$v] * 8) / [double]$CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v]) * 100
                [void] $alValues.Add($iPercentageOfNetworkUtilization)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterComputer)\$($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterObject)($($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterInstance))\% Network Utilization Received"
            $CollectionOfReceivedNetworkUtilization.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 30% network utilization received" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfReceivedNetworkUtilization -Operator 'gt' -Threshold 30
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 50% network utilization received" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfReceivedNetworkUtilization -Operator 'gt' -Threshold 50

        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="% Network Utilization Received" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\% Network Utilization Received" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfReceivedNetworkUtilization -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfReceivedNetworkUtilization -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ % Network Utilization Received doesn't exist as a normal performance counter, so this analysis uses multiplies <B>\Network Interface(*)\Bytes Received/sec</B> by 8 (to convert it to bits total/sec), divides it by <B>\Network Interface(*)\Current Bandwidth</B>, and multiplies the result by 100 to create a percentage. This analysis throws a warning alert when greater than 50 and throws a critical alert when greater than 80.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="System Processor Queue Length" ENABLED="True" CATEGORY="System" PRIMARYDATASOURCE="\System\Processor Queue Length" ID="{36a4a252-92de-4d0c-9a28-ca817290ec75}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\System\Processor Queue Length" COLLECTIONVARNAME="SystemProcessorQueueLength" EXPRESSIONPATH="\System\Processor Queue Length" DATATYPE="Integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Processor Time" EXPRESSIONPATH="\Processor(*)\% Processor Time" COLLECTIONVARNAME="CollectionOfProcessorPercentProcessorTime" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 2 ready threads are queued for each processor" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
  [Int] $NumberOfLogicalProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($NumberOfLogicalProcessors -eq 0)
  {
    $NumberOfLogicalProcessors = 1
  }
  $TwoTimesNumberOfProcessors = $NumberOfLogicalProcessors * 2
  StaticThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -Operator 'gt' -Threshold $TwoTimesNumberOfProcessors]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 10 ready threads are queued for each processor" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
  [Int] $NumberOfLogicalProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($NumberOfLogicalProcessors -eq 0)
  {
    $NumberOfLogicalProcessors = 1
  }
  $TenTimesNumberOfProcessors = [Int] $NumberOfLogicalProcessors * 10
  StaticThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -Operator 'gt' -Threshold $TenTimesNumberOfProcessors]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\System\Processor Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\System\Processor Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
  [Int] $NumberOfLogicalProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($NumberOfLogicalProcessors -eq 0)
  {
    $NumberOfLogicalProcessors = 1
  }
  $TwoTimesNumberOfProcessors = [Int] $NumberOfLogicalProcessors * 2
  $TenTimesNumberOfProcessors = ([Int] $NumberOfLogicalProcessors * 10) - 0.001
  StaticChartThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -MinThreshold $TwoTimesNumberOfProcessors -MaxThreshold $TenTimesNumberOfProcessors
 ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
  [Int] $NumberOfLogicalProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($NumberOfLogicalProcessors -eq 0)
  {
    $NumberOfLogicalProcessors = 1
  }
  $TenTimesNumberOfProcessors = [Int] $NumberOfLogicalProcessors * 10
  $TwentyTimesNumberOfProcessors = ([Int] $NumberOfLogicalProcessors * 20) - 0.001
  StaticChartThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -MinThreshold $TenTimesNumberOfProcessors -MaxThreshold $TwentyTimesNumberOfProcessors
]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Processor Queue Length is the number of threads in the processor queue. Unlike the disk counters, this counter shows ready threads only, not threads that are running. There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.<BR>

<BR>

This analysis determines if the average processor queue length exceeds the number of processors. If so, then this could indicate a processor bottleneck. Use this analysis in correlation with Privileged Mode CPU Analysis and Excessive Processor Use by Process analysis.<BR>

<BR>
<b>Note:</b> Due to the way in which this counter is collected, ignore this counter and alerts for it when collected from a virtual computer.<BR>
<BR>

If there are more tasks ready to run than there are processors, threads queue up. The processor queue is the collection of threads that are ready but not able to be executed by the processor because another active thread is currently executing. A sustained or recurring queue of more threads than number of processors is a good indication of a processor bottleneck.<BR>

<BR>

You can use this counter in conjunction with the <B>\Processor\% Processor Time</B> counter to determine if your application can benefit from more CPUs.<BR>

<BR>

<B>Reference:</B>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
</UL>
 ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="System Context Switching" ENABLED="False" CATEGORY="System" PRIMARYDATASOURCE="\System\Context Switches/sec" ID="{c0eb3777-a89d-4889-bc37-2f5865a928ee}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\System\Context Switches/sec" COLLECTIONVARNAME="SystemContextSwitchessec" EXPRESSIONPATH="\System\Context Switches/sec" DATATYPE="Integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Privileged Time" EXPRESSIONPATH="\Processor(*)\% Privileged Time" COLLECTIONVARNAME="CollectionOfProcessorPercentPrivilegedTimeAll" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Processor Time" EXPRESSIONPATH="\Processor(*)\% Processor Time" COLLECTIONVARNAME="CollectionOfProcessorPercentProcessorTime" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\System\Processor Queue Length" EXPRESSIONPATH="\System\Processor Queue Length" COLLECTIONVARNAME="CollectionOfSystemProcessorQueueLength" DATATYPE="integer" />
    <THRESHOLD NAME="More than 2,500 Context Switches/sec per processor, more than 20% ratio of privileged to total CPU, and more than 50% total processor time or more than 10,000 Context Switches/sec" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
  [Int] $TempNumberOfProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($TempNumberOfProcessors -eq 0)
  {
    $TempNumberOfProcessors = 1
  }
  
        $TempNumberOfProcessors = [Int] $TempNumberOfProcessors
          If ($TempNumberOfProcessors -ge 1)
          {
            $TwentyFiveHundredTimesNumberOfProcessors = ($TempNumberOfProcessors * 2500)
          }
          Else
          {
            $TwentyFiveHundredTimesNumberOfProcessors = 2500
          }
          For ($i=0;$i -lt $SystemContextSwitchessec.Count;$i++)
          {
            $oCounterInstance = $SystemContextSwitchessec[$i]
            For ($t=0;$t -lt $global:oPal.QuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
              If (($oCounterInstance.QuantizedMin[$t] -ne '-') -and ($oCounterInstance.QuantizedMin[$t] -ne $null))
              {
                If (($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t] -ne '-') -and ($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t] -ne $null))
                {
                  If (($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMin[$t] -ne '-') -and ($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMin[$t] -ne $null))
                  {
                    $PercentageOfPrivilegedModeCPUToTotalCPU = ($($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMin[$t]) * 100) / $($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t])
                    If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 20) -and ($($oCounterInstance.QuantizedMin[$t]) -gt $TwentyFiveHundredTimesNumberOfProcessors) -and ($($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t]) -gt 50))
                    {
                      $IsMinThresholdBroken = $True
                      $IsMinEvaluated = $True
                    }
                    If ($($oCounterInstance.QuantizedMin[$t]) -gt 10000)
                    {
                      $IsMinThresholdBroken = $True
                      $IsMinEvaluated = $True
                    }
                  }
                }
              }
            
              If (($oCounterInstance.QuantizedAvg[$t] -ne '-') -and ($oCounterInstance.QuantizedAvg[$t] -ne $null))
              {
                If (($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t] -ne '-') -and ($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t] -ne $null))
                {
                  If (($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedAvg[$t] -ne '-') -and ($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedAvg[$t] -ne $null))
                  {
                    $PercentageOfPrivilegedModeCPUToTotalCPU = ($($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedAvg[$t]) * 100) / $($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t])
                    If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 20) -and ($($oCounterInstance.QuantizedAvg[$t]) -gt $TwentyFiveHundredTimesNumberOfProcessors) -and ($($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t]) -gt 50))
                    {
                      $IsAvgThresholdBroken = $True
                      $IsAvgEvaluated = $True
                    }
                    If ($($oCounterInstance.QuantizedAvg[$t]) -gt 10000)
                    {
                      $IsAvgThresholdBroken = $True
                      $IsAvgEvaluated = $True
                    }
                  }
                }
              }
              If (($oCounterInstance.QuantizedMax[$t] -ne '-') -and ($oCounterInstance.QuantizedMax[$t] -ne $null))
              {
                If (($CollectionOfProcessorPercentProcessorTime[$i].QuantizedMax[$t] -ne '-') -and ($CollectionOfProcessorPercentProcessorTime[$i].QuantizedMax[$t] -ne $null))
                {
                  If (($CollectionOfProcessorPercentPrivilegedTimeAll[$i].QuantizedMax[$t] -ne '-') -and ($CollectionOfProcessorPercentPrivilegedTimeAll[$i].QuantizedMax[$t] -ne $null))
                  {
                    $PercentageOfPrivilegedModeCPUToTotalCPU = ($($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMax[$t]) * 100) / $($CollectionOfProcessorPercentProcessorTime[$i].QuantizedMax[$t])
                    If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 20) -and ($($oCounterInstance.QuantizedMax[$t]) -gt $TwentyFiveHundredTimesNumberOfProcessors) -and ($($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t]) -gt 50))
                    {
                      $IsMaxThresholdBroken = $True
                      $IsMaxEvaluated = $True
                    }
                    If ($($oCounterInstance.QuantizedMax[$t]) -gt 10000)
                    {
                      $IsMaxThresholdBroken = $True
                      $IsMaxEvaluated = $True
                    }                    
                  }
                }
              }        
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaluated -IsAvgEvaluated $IsAvgEvaluated -IsMaxEvaluated $IsMaxEvaluated -IsTrendEvaluated $IsTrendEvaluated
              }
            }
          }]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 5,000 Context Switches/sec per processor, more than 30% ratio of privileged to total CPU, and more than 70% total processor time or more than 20,000 Context Switches/sec" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.

  [Int] $TempNumberOfProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($TempNumberOfProcessors -eq 0)
  {
    $TempNumberOfProcessors = 1
  }

$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
	$FiveThousandTimesNumberOfProcessors = ($TempNumberOfProcessors * 5000)
}
Else
{
	$FiveThousandTimesNumberOfProcessors = 5000
}
For ($i=0;$i -lt $SystemContextSwitchessec.Count;$i++)
{
	$oCounterInstance = $SystemContextSwitchessec[$i]
	For ($t=0;$t -lt $global:oPal.QuantizedTime.Count;$t++)
	{
	  $IsMinThresholdBroken = $False
	  $IsAvgThresholdBroken = $False
	  $IsMaxThresholdBroken = $False
	  $IsTrendThresholdBroken = $False
	  $IsMinEvaluated = $False
	  $IsAvgEvaluated = $False
	  $IsMaxEvaluated = $False
	  $IsTrendEvaluated = $False

	  If (($oCounterInstance.QuantizedMin[$t] -ne '-') -and ($oCounterInstance.QuantizedMin[$t] -ne $null))
	  {
	    If (($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t] -ne '-') -and ($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t] -ne $null))
	    {
	      If (($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMin[$t] -ne '-') -and ($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMin[$t] -ne $null))
	      {
	        $PercentageOfPrivilegedModeCPUToTotalCPU = ($($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMin[$t]) * 100) / $($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t])
	        If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 30) -and ($($oCounterInstance.QuantizedMin[$t]) -gt $FiveThousandTimesNumberOfProcessors) -and ($($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t]) -gt 70))
	        {
	          $IsMinThresholdBroken = $True
	          $IsMinEvaluated = $True
	        }
	        If ($($oCounterInstance.QuantizedMin[$t]) -gt 20000)
	        {
	          $IsMinThresholdBroken = $True
	          $IsMinEvaluated = $True
	        }
	      }
	    }
	  }

	  If (($oCounterInstance.QuantizedAvg[$t] -ne '-') -and ($oCounterInstance.QuantizedAvg[$t] -ne $null))
	  {
	    If (($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t] -ne '-') -and ($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t] -ne $null))
	    {
	      If (($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedAvg[$t] -ne '-') -and ($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedAvg[$t] -ne $null))
	      {
	        $PercentageOfPrivilegedModeCPUToTotalCPU = ($($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedAvg[$t]) * 100) / $($CollectionOfProcessorPercentProcessorTime[0].QuantizedAvg[$t])
	        If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 30) -and ($($oCounterInstance.QuantizedAvg[$t]) -gt $FiveThousandTimesNumberOfProcessors) -and ($($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t]) -gt 70))
	        {
	          $IsAvgThresholdBroken = $True
	          $IsAvgEvaluated = $True
	        }
	        If ($($oCounterInstance.QuantizedAvg[$t]) -gt 20000)
	        {
	          $IsAvgThresholdBroken = $True
	          $IsAvgEvaluated = $True
	        }                    
	      }
	    }
	  }
	  If (($oCounterInstance.QuantizedMax[$t] -ne '-') -and ($oCounterInstance.QuantizedMax[$t] -ne $null))
	  {
	    If (($CollectionOfProcessorPercentProcessorTime[$i].QuantizedMax[$t] -ne '-') -and ($CollectionOfProcessorPercentProcessorTime[$i].QuantizedMax[$t] -ne $null))
	    {
	      If (($CollectionOfProcessorPercentPrivilegedTimeAll[$i].QuantizedMax[$t] -ne '-') -and ($CollectionOfProcessorPercentPrivilegedTimeAll[$i].QuantizedMax[$t] -ne $null))
	      {
	        $PercentageOfPrivilegedModeCPUToTotalCPU = ($($CollectionOfProcessorPercentPrivilegedTimeAll[0].QuantizedMax[$t]) * 100) / $($CollectionOfProcessorPercentProcessorTime[$i].QuantizedMax[$t])
	        If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 30) -and ($($oCounterInstance.QuantizedMax[$t]) -gt $FiveThousandTimesNumberOfProcessors) -and ($($CollectionOfProcessorPercentProcessorTime[0].QuantizedMin[$t]) -gt 70))
	        {
	          $IsMaxThresholdBroken = $True
	          $IsMaxEvaluated = $True
	        }
	        If ($($oCounterInstance.QuantizedMax[$t]) -gt 20000)
	        {
	          $IsMaxThresholdBroken = $True
	          $IsMaxEvaluated = $True
	        }                    
	      }
	    }
	  }        
	  If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
	  {
	      CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaluated -IsAvgEvaluated $IsAvgEvaluated -IsMaxEvaluated $IsMaxEvaluated -IsTrendEvaluated $IsTrendEvaluated
	  }
	}
} ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\System\Context Switches/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\System\Context Switches/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.

  [Int] $NumberOfLogicalProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($NumberOfLogicalProcessors -eq 0)
  {
    $NumberOfLogicalProcessors = 1
  }
  
If ($NumberOfLogicalProcessors -ge 1)
{
	$TwentyFiveHundredTimesNumberOfProcessors = ($NumberOfLogicalProcessors * 2500) - 0.001
}
Else
{
	$TwentyFiveHundredTimesNumberOfProcessors = 2500 - 0.001
}
$DoubleTwentyFiveHundredTimesNumberOfProcessors = $TwentyFiveHundredTimesNumberOfProcessors * 2
StaticChartThreshold -CollectionOfCounterInstances $SystemContextSwitchessec -MinThreshold $TwentyFiveHundredTimesNumberOfProcessors -MaxThreshold $DoubleTwentyFiveHundredTimesNumberOfProcessors]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
        
  [Int] $NumberOfLogicalProcessors = $CollectionOfProcessorPercentProcessorTime.Count - 1
  If ($NumberOfLogicalProcessors -eq 0)
  {
    $NumberOfLogicalProcessors = 1
  }
  
If ($NumberOfLogicalProcessors -ge 1)
{
	$TwentyFiveHundredTimesNumberOfProcessors = ($NumberOfLogicalProcessors * 2500)
	$FiveThousandTimesNumberOfProcessors = ($NumberOfLogicalProcessors * 5000)
}
Else
{
	$TwentyFiveHundredTimesNumberOfProcessors = 2500
  $FiveThousandTimesNumberOfProcessors = 5000	
}
$DoubleTwentyFiveHundredTimesNumberOfProcessors = ($TwentyFiveHundredTimesNumberOfProcessors * 2) - 0.001
$DoubleFiveThousandTimesNumberOfProcessors = ($FiveThousandTimesNumberOfProcessors * 2) - 0.001
StaticChartThreshold -CollectionOfCounterInstances $SystemContextSwitchessec -MinThreshold $DoubleTwentyFiveHundredTimesNumberOfProcessors -MaxThreshold $DoubleFiveThousandTimesNumberOfProcessors]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[
Context Switches/sec is the combined rate at which all processors on the computer are switched from one thread to another. Context switches occur when a running thread voluntarily relinquishes the processor, is preempted by a higher priority ready thread, or switches between user-mode and privileged (kernel) mode to use an Executive or subsystem service. It is the sum of Thread\\Context Switches/sec for all threads running on all processors in the computer and is measured in numbers of switches.  There are context switch counters on the System and Thread objects. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.<BR>
<BR>
High context switching is only a problem if overall CPU is high as well. This analysis checks for high CPU, high privileged mode CPU, and high system context switches per sec.<BR>
<BR>
Threshold: As a general rule, context switching rates of greater than 5,000 per second per processor are considered a warning. If context switching rates exceed 10,000 per second per processor, then there is a constraint.<BR>
<BR>
Significance: Context switching happens when a higher priority thread preempts a lower priority thread that is currently running or when a high priority thread blocks. High levels of context switching can occur when many threads share the same priority level. This often indicates that there are too many threads competing for the processors on the system. If you do not see much processor utilization and you see very low levels of context switching, it could indicate that threads are blocked.<BR>
<BR>
<B>Reference:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Private Bytes" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Private Bytes" ID="{bf135d67-22c5-4839-b039-3b8c0e587cd8}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Private Bytes" COLLECTIONVARNAME="ProcessPrivateBytesTotal" EXPRESSIONPATH="\Process(_Total)\Private Bytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(_Total)\Private Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Private Bytes" CHARTLABELS="instance">
    </CHART>
    <THRESHOLD NAME="Increasing trend of more than 100 MB of private bytes per hour - may not be accurate on counter logs of less than 1 hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $ProcessPrivateBytesTotal -Operator 'gt' -Threshold 100MB -IsTrendOnly $True]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis determines if the system leaking memory over time. A process consuming large portions of memory is okay as long as the process returns the memory back to the system. Look for increasing trends in the chart. An increasing trend over a long period of time could indicate a memory leak. Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes. This analysis checks for a 10 MB per hour and 5 MB per hour increasing trends. Use this analysis in correlation with the Available Memory analysis.<BR>
<BR>
Use this analysis in correlation with the Available Memory analysis. If you suspect a memory leak condition, then install and use the Debug Diag tool. For more information on the Debug Diag Tool, see the references section.<BR>
<BR>
<B>References:</B><BR>

Debug Diagnostic Tool v1.1 http://www.microsoft.com/downloads/details.aspx?FamilyID=28bd5941-c458-46f1-b24d-f60151d875a3&displaylang=en]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Handle Count" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Handle Count" ID="{ff63f07d-dec2-4abc-b99a-d1841d340695}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Handle Count" COLLECTIONVARNAME="ProcessHandleCountTotal" EXPRESSIONPATH="\Process(_Total)\Handle Count" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(_Total)\Handle Count" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Handle Count" CHARTLABELS="instance" />
    <THRESHOLD NAME="Increasing trend of more than 100 handles per hour - may not be accurate on counter logs of less than 1 hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $ProcessHandleCountTotal -Operator 'gt' -Threshold 100 -IsTrendOnly $True]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis checks overall system to determine how many handles the system has open to determine if there is a handle leak. Handle leaks can be attributed to memory leak. If this analysis throws alerts, then you need to manually open the performance monitor log and look at the instances <B>\Process(_Total)\Handle Count</B> to determine which process is leaking handles. Note: The normal System Overview analysis checks all of the processes.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Thread Count" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Thread Count" ID="{cc52e99a-9c8a-4b5d-91c7-11dcb2ac9f77}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Thread Count" COLLECTIONVARNAME="ProcessThreadCountTotal" EXPRESSIONPATH="\Process(_Total)\Thread Count" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(_Total)\Thread Count" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Thread Count" CHARTLABELS="instance" />
    <THRESHOLD NAME="Increasing trend of more than 100 threads per hour - may not be accurate on counter logs of less than 1 hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $ProcessThreadCountTotal -Operator 'gt' -Threshold 100 -IsTrendOnly $True]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.<BR>
<BR>
This analysis checks all of the processes to determine if a process has more than 500 threads and if it is on an increasing trend of 50 threads per hour. A process with a large number of threads and/or an aggressive upward trend could indicate a thread leak which typically results in either a memory leak or high context switching. High context switching will result in high privileged mode CPU. ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Disk Overwhelmed" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Overwhelmed" ID="889e93de-3c7d-45af-b523-6ce4dd88bf1d" FROMALLCOUNTERSTATS="False">
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Overwhelmed" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Disk Overwhelmed" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskDiskOverwhelmedAll -MinThreshold 0.75 -MaxThreshold 1 -IsOperatorGreaterThan $True -UseMaxValue $False]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskDiskOverwhelmedAll -MinThreshold 1 -MaxThreshold 1.999 -IsOperatorGreaterThan $True -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Transfer" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Transfer" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDisksecTransferAll" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Bytes/Transfer" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Bytes/Transfer" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskBytesTransferAll" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Queue Length" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Queue Length" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskQueueLengthAll" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\LogicalDisk(*)\Disk Overwhelmed" EXPRESSIONPATH="\LogicalDisk(*)\Disk Overwhelmed" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskOverwhelmedAll" DATATYPE="round2">
      <CODE><![CDATA[
          $CollectionOfLogicalDiskDiskOverwhelmedAll = @{}
          [int] $i = '';[int] $r = '';[int] $s = ''
          For ($i=0;$i -lt $CollectionOfLogicalDiskAvgDiskQueueLengthAll.Count;$i++)
          {
            $InstanceOfLogicalDiskAvgDiskQueueLength = $CollectionOfLogicalDiskAvgDiskQueueLengthAll[$i]
            For ($a=0;$a -lt $CollectionOfLogicalDiskAvgDisksecTransferAll.Count;$a++)
            {
              If ($InstanceOfLogicalDiskAvgDiskQueueLength.CounterInstance -eq $CollectionOfLogicalDiskAvgDisksecTransferAll[$a].CounterInstance)
              { 
                $InstanceOfLogicalDiskAvgDisksecTransfer = $CollectionOfLogicalDiskAvgDisksecTransferAll[$a]
              }
            }
            For ($a=0;$a -lt $CollectionOfLogicalDiskAvgDiskBytesTransferAll.Count;$a++)
            {
              If ($InstanceOfLogicalDiskAvgDiskQueueLength.CounterInstance -eq $CollectionOfLogicalDiskAvgDiskBytesTransferAll[$a].CounterInstance)
              { 
                $InstanceOfLogicalDiskAvgDiskBytesTransfer = $CollectionOfLogicalDiskAvgDiskBytesTransferAll[$a]
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $InstanceOfLogicalDiskAvgDiskQueueLength.Value.Count;$v++)
            {
              If ($InstanceOfLogicalDiskAvgDiskBytesTransfer.Value[$v] -gt 65536)
              {
                $ResponseTimeCriticalThreshold = 0.035
              }
              Else
              {
                $ResponseTimeCriticalThreshold = 0.025
              }
                            
              If (($InstanceOfLogicalDiskAvgDiskQueueLength.Value[$v] -ge 1) -and ($InstanceOfLogicalDiskAvgDisksecTransfer.Value[$v] -gt $ResponseTimeCriticalThreshold))
              {
                [void] $alValues.Add(2)
              }
              Else
              {
                If (($InstanceOfLogicalDiskAvgDiskQueueLength.Value[$v] -ge 1) -and ($InstanceOfLogicalDiskAvgDisksecTransfer.Value[$v] -gt 0.015))
                {
                  [void] $alValues.Add(1)
                }
                Else
                {
                  [void] $alValues.Add(0)
                }                  
              }
            }
            $sGeneratedInstanceName = "\\$($InstanceOfLogicalDiskAvgDiskQueueLength.CounterComputer)\$($InstanceOfLogicalDiskAvgDiskQueueLength.CounterObject)($($InstanceOfLogicalDiskAvgDiskQueueLength.CounterInstance))\Disk Overwhelmed"
            $CollectionOfLogicalDiskDiskOverwhelmedAll.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Disk overwhelmed: Avg Disk Queue Length is greater than 1 and response times are greater than 25 ms for IO sizes of 64 KB or smaller or 35 ms for IO sizes greater than 64 KB." CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskDiskOverwhelmedAll -Operator 'ge' -Threshold 2]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Disk approaching overwhelmed: Avg Disk Queue Length is greater than 1 and response times are greater than 15 ms" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskDiskOverwhelmedAll -Operator 'ge' -Threshold 1]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis is an attempt to determine if a logical disk is overwhelmed by making a complicated formula into a simple good (green), warning (yellow), or critical (red) status.<BR>
<BR>
This analysis takes into consideration the workload of the disk queue, the size of the IO, and the response times to compute a good or bad condition in regards to if the disk is overwhelmed or not. If <B>Avg Disk Queue Length</B> is greater than 1 and response times are greater than 25 ms for IO sizes of 64 KB or smaller or 35 ms for IO sizes greater than 64 KB, then the disk is overwhelmed. The reasoning is that the disk has a nearly constant IO demand (<B>Avg Disk Queue Length</B> is a calculation of Transfers/sec and sec/Transfer) and the response times are higher than what it would take a 7200 RPM disk drive to return the appropriate IO sizes. This analysis requires <B>\LogicalDisk(*)\Avg. Disk Queue Length</B>, <B>\LogicalDisk(*)\Avg. Disk Bytes/Transfer</B>, and <B>\LogicalDisk(*)\Avg. Disk sec/Transfer</B> counters to be in the counter log. Instances of _Total are ignored because they are aggregates of all counter instances.<BR>
<BR>
If the PAL generated counter of <B>\LogicalDisk(*)\Disk Overwhelmed</B> has a value of 1 (Warning), then it means that the <B>Avg Disk Queue Length</B> is greater than 1 and the response times (<B>Avg. Disk sec/Transfer</B>) are greater than 15 ms. If this counter has a value of 2 (Critical), then it means that<B>Avg Disk Queue Length</B> is greater than 1 and the response times are greater than 25 ms for IO of 64 KB or smaller and 35 ms for IO sizes greater than 64 KB.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk % Free Space" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\% Free Space" ID="{6e4c9856-14cf-48b2-b519-e120b8a21d45}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\% Free Space" COLLECTIONVARNAME="LogicalDiskPercentFreeSpace" EXPRESSIONPATH="\LogicalDisk(*)\% Free Space" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="HarddiskVolume1" />
    </DATASOURCE>
    <THRESHOLD NAME="Less than 10% free disk space" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -Operator 'lt' -Threshold 10
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 5% free disk space" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -Operator 'lt' -Threshold 5
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\% Free Space" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\% Free Space" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -MinThreshold 5 -MaxThreshold 10 -IsOperatorGreaterThan $False -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -MinThreshold 0 -MaxThreshold 5 -IsOperatorGreaterThan $False -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Free Space is the percentage of total usable space on the selected logical disk drive that was free. Low to no free disk space can cause severe disk performance problems.This analysis checks for less than 10% free disk space (Warning alert) and less than 5% free disk space (Critical alert).]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % Interrupt Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% Interrupt Time" ID="{a2cb1d88-1b9d-4a55-bfb5-92337f23d426}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Interrupt Time" COLLECTIONVARNAME="ProcessorPercentInterruptTimeALL" EXPRESSIONPATH="\Processor(*)\% Interrupt Time" DATATYPE="integer" />
    <THRESHOLD NAME="More than 10% Interrupt Time" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -Operator 'gt' -Threshold 10]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 20% Interrupt Time" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -Operator 'gt' -Threshold 20]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Processor(*)\% Interrupt Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% Interrupt Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -MinThreshold 30 -MaxThreshold 50 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -MinThreshold 50 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. A dramatic increase in this counter indicates potential hardware problems.<BR>
<BR>
This analysis checks for % Interrupt Time greater than 30%. If this occurs, then consider updating devices drivers for hardware that correlates to this alert.<BR>
<BR>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Read Latency Analysis" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Read" ID="{8839eef1-a97f-443d-b8a7-89079d0d6ff1}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Avg. Disk sec/Read" COLLECTIONVARNAME="PhysicalDiskAvgDisksecReadALL" EXPRESSIONPATH="\PhysicalDisk(*)\Avg. Disk sec/Read" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15 ms physical disk READ response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25 ms physical disk READ response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.025
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Avg. Disk sec/Read" ISTHRESHOLDSADDED="True" DATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Read" CHARTLABELS="instance" MAXLIMIT="0.099999">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -MinThreshold 0.025 -MaxThreshold 0.099999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>0.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand.<BR>
<BR>
If the response times are greater than <B>0.025 (25 milliseconds)</B>, then the disk subsystem is likely overwhelmed.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Write Latency Analysis" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Write" ID="{d8115038-5c2b-4495-b418-e36510296b43}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Avg. Disk sec/Write" COLLECTIONVARNAME="PhysicalDiskAvgDisksecWriteALL" EXPRESSIONPATH="\PhysicalDisk(*)\Avg. Disk sec/Write" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15 ms physical disk WRITE response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25 ms physical disk WRITE response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.025
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Avg. Disk sec/Write" ISTHRESHOLDSADDED="True" DATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Write" CHARTLABELS="instance" MAXLIMIT="0.099999">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -MinThreshold 0.025 -MaxThreshold 0.099999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>0.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand.<BR>
<BR>
If the response times are greater than <B>0.025 (25 milliseconds)</B>, then the disk subsystem is likely overwhelmed.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Avg. Disk sec/Read" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" ID="{dfb21d00-cf83-49e7-bf63-3d82db3d63c3}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Read" COLLECTIONVARNAME="LogicalDiskAvgDisksecReadALL" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Read" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15 ms logical disk READ response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25 ms logical disk READ response times" CONDITION="Critical" COLOR="Red" PRIORITY="99" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.025]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Read" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" CHARTLABELS="instance" MAXLIMIT="0.099999">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -MinThreshold 0.025 -MaxThreshold 0.099999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Greater than 600 ms - Slower than a 3.5 inch floppy drive" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.6]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the logical disks are responding slowly.<BR>
<BR>
The following thresholds are based on the access times of 5400 RPM disk drives. Hard drives that are faster than 5400 RPM such as 7200 RPM and solid state drives should have faster response times. Occasional spikes above 25 ms are normal.<BR>
<BR>
If the response times are less than <B>0.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand.<BR>
<BR>
If the response times are greater than <B>0.025 (25 milliseconds)</B>, then the disk subsystem is likely overwhelmed.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Avg. Disk sec/Write" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" ID="{28eaa0b2-0bc2-41f8-8c27-9045b597d001}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Write" COLLECTIONVARNAME="LogicalDiskAvgDisksecWriteALL" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Write" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15 ms logical disk WRITE response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25 ms logical disk WRITE response times" CONDITION="Critical" COLOR="Red" PRIORITY="99" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.025]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Write" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" CHARTLABELS="instance" MAXLIMIT="0.099999">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -MinThreshold 0.025 -MaxThreshold 0.099999 -UseMaxValue $False]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Greater than 600 ms - Slower than a 3.5 inch floppy drive" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.6]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the logical disks are responding slowly.<BR>
<BR>
The following thresholds are based on the access times of 5400 RPM disk drives. Hard drives that are faster than 5400 RPM such as 7200 RPM and solid state drives should have faster response times. Occasional spikes above 25 ms are normal.<BR>
<BR>
If the response times are less than <B>0.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand.<BR>
<BR>
If the response times are greater than <B>0.025 (25 milliseconds)</B>, then the disk subsystem is likely overwhelmed.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk % Idle Time" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\% Idle Time" ID="{91e5c328-0ca6-4b1f-a4f5-7f32d9cd357a}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\% Idle Time" COLLECTIONVARNAME="CollectionOfLogicalDiskPercentIdleTimeALL" EXPRESSIONPATH="\LogicalDisk(*)\% Idle Time" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Less than 10% Idle Time - the disk queue has at least 1 outstanding I/O 90% of the time" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskPercentIdleTimeALL -Operator 'lt' -Threshold 10]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\% Idle Time" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\% Idle Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskPercentIdleTimeALL -MinThreshold 0 -MaxThreshold 10 -UseMaxValue $False -IsOperatorGreaterThan $False]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Idle Time reports the percentage of time during the sample interval that the disk was idle.<BR>
<BR>
This analysis checks for a % Idle Time of less than 10. Zero (0) indicates that the disk contstanly has at least 1 outstanding I/O in the queue.
<BR><BR>
<B>Reference:</B>
<UL>
<LI><A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">Ruling Out Disk-Bound Problems</A></LI>
</UL
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Free System Page Table Entries" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Free System Page Table Entries" ID="{0b445fb5-2530-43cb-a7be-79cc43f212bc}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Free System Page Table Entries" COLLECTIONVARNAME="MemoryFreeSystemPageTableEntries" EXPRESSIONPATH="\Memory\Free System Page Table Entries" DATATYPE="Integer" />
    <THRESHOLD NAME="Less than 20,000 Free Page Table Entries (PTE) - The system is low on free PTEs" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -Operator 'lt' -Threshold 20000
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 8,000 Free Page Table Entries - The system is critically low on free PTEs" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -Operator 'lt' -Threshold 8000
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Free System Page Table Entries" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Free System Page Table Entries" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -MinThreshold 8000 -MaxThreshold 20000 -IsOperatorGreaterThan $False -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -MinThreshold 0 -MaxThreshold 8000 -IsOperatorGreaterThan $False -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Free System Page Table Entries is the number of page table entries not currently in used by the system. This analysis determines if the system is running out of free system page table entries (PTEs) by checking if there is less than 20,000 free PTE's as a Warning and critical if there is less than 8,000 free PTEs. Lack of enough PTEs can result in system wide hangs. Also note that the /3GB switch will lower the amount of free PTEs significantly. <BR>
<BR>
The Performance Monitor Memory\Free System Page Table Entries counter is inaccurate on installations of Windows Server 2003 without Service Pack 1. For more information about this counter, see Microsoft Knowledge Base article 894067. The Performance tool does not accurately show the available Free System Page Table entries in Windows Server 2003 <a href="http://go.microsoft.com/fwlink/?linkid=3052&kbid=894067">http://go.microsoft.com/fwlink/?linkid=3052&amp;kbid=894067</a><BR>
<BR>
<B>Fix for Win2003 SP1 systems with /3GB and low on PTE's:</B> If the system is low on PTE's, running Windows 2003, and using /3GB switch, then consider using the /USERVA switch to give back some of the memory to the kernel. Note, this only works for Free System PTE issues.<BR>
<BR>
For more information on the USERVA switch, go to:
<A HREF="http://support.microsoft.com/kb/316739">How to use the /userva switch with the /3GB switch to tune the User-mode space to a value between 2 GB and 3 GB</A><BR>
<BR>
<B>Reference:</B><BR>
<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">Ruling Out Memory-Bound Problems</A><BR>
<BR>
<A HREF="http://support.microsoft.com/kb/894067">Microsoft Knowledge Base article 894067 The Performance tool does not accurately show the available Free System Page Table entries in Windows Server 2003</A><BR>
<BR>
<A HREF="http://support.microsoft.com/kb/316739">How to use the /userva switch with the /3GB switch to tune the User-mode space to a value between 2 GB and 3 GB</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pool Non-Paged Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pool Nonpaged Bytes" ID="{8eb3c4cb-b877-4878-9882-5654fea10320}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pool Nonpaged Bytes" COLLECTIONVARNAME="MemoryPoolNonpagedBytes" EXPRESSIONPATH="\Memory\Pool Nonpaged Bytes" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 60% of Pool Non-Paged Kernel Memory Used" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE>
    <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()

switch ($OS)
{
  'WINDOWS XP 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS XP 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }
  
  'WINDOWS SERVER 2003 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS SERVER 2003 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }

  'WINDOWS VISTA 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS VISTA 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS SERVER 2008 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
  'WINDOWS SERVER 2008 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS 7 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS 7 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }
  
	'WINDOWS SERVER 2008 R2 64-BIT'
	{
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
	}
  
  'WINDOWS 8 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
	default
	{
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
	} 
  
}
$SixtyPercentOfMemoryPoolMaximum = $iMemPoolMax * 0.60
StaticThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -Operator 'gt' -Threshold $SixtyPercentOfMemoryPoolMaximum
 ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% of Pool Non-Paged Kernel Memory Used" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE>
    <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()

switch ($OS)
{
  'WINDOWS XP 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS XP 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }
  
  'WINDOWS SERVER 2003 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS SERVER 2003 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }

  'WINDOWS VISTA 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS VISTA 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS SERVER 2008 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
  'WINDOWS SERVER 2008 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS 7 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS 7 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }
  
	'WINDOWS SERVER 2008 R2 64-BIT'
	{
		#// 75 percent of RAM or 128 GB, whichever is smaller
		$iMemPoolMax = ($iPhysicalMemory * 0.75)
		If ($iMemPoolMax -gt 128GB)
		{$iMemPoolMax = 128GB}
	}
  
  'WINDOWS 8 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
	default
	{
		#// 75 percent of RAM or 128 GB, whichever is smaller
		$iMemPoolMax = ($iPhysicalMemory * 0.75)
		If ($iMemPoolMax -gt 128GB)
		{$iMemPoolMax = 128GB}
	}
}

$EightyPercentOfMemoryPoolMaximum = $iMemPoolMax * 0.80
StaticThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -Operator 'gt' -Threshold $EightyPercentOfMemoryPoolMaximum
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Pool Nonpaged Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Pool Nonpaged Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE>
    <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()
switch ($OS)
{
  'WINDOWS XP 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS XP 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }
  
  'WINDOWS SERVER 2003 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS SERVER 2003 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }

  'WINDOWS VISTA 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS VISTA 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS SERVER 2008 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
  'WINDOWS SERVER 2008 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS 7 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS 7 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }
  
	'WINDOWS SERVER 2008 R2 64-BIT'
	{
		#// 75 percent of RAM or 128 GB, whichever is smaller
		$iMemPoolMax = ($iPhysicalMemory * 0.75)
		If ($iMemPoolMax -gt 128GB)
		{$iMemPoolMax = 128GB}
	}
  
  'WINDOWS 8 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
	default
	{
		#// 75 percent of RAM or 128 GB, whichever is smaller
		$iMemPoolMax = ($iPhysicalMemory * 0.75)
		If ($iMemPoolMax -gt 128GB)
		{$iMemPoolMax = 128GB}
	}
}

$SixtyPercentOfMemoryPoolMaximum = $iMemPoolMax * 0.60
$EightyPercentOfMemoryPoolMaximum = ($iMemPoolMax * 0.80) - 0.001
StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -MinThreshold $SixtyPercentOfMemoryPoolMaximum -MaxThreshold $EightyPercentOfMemoryPoolMaximum -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE>
    <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()
switch ($OS)
{
  'WINDOWS XP 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS XP 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }
  
  'WINDOWS SERVER 2003 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {$iMemPoolMax = 128 * 1MB}
	  Else 
	  {
		  If ($iPhysicalMemory -le 1GB)
		  {$iMemPoolMax = 208 * 1MB}
		  Else {$iMemPoolMax = 256 * 1MB}
	  }
  }
  
  'WINDOWS SERVER 2003 64-BIT'
  {
    $iMemPoolMax = $iPhysicalMemory * 0.75
  }

  'WINDOWS VISTA 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS VISTA 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS SERVER 2008 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
  'WINDOWS SERVER 2008 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }

  'WINDOWS 7 32-BIT'
  {
		If ($UserVa -gt 2048) #// If /3GB
		{
			#// 75 percent of RAM or KernelVa size, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			$iKernelVa = (4096 - $UserVa) * 1MB
			If ($iKernelVa -lt $iMemPoolMax)
			{$iMemPoolMax = $iKernelVa}
		}
		Else 
		{
			#// 75 percent of RAM or 2 GB, whichever is smaller
			$iMemPoolMax = ($iPhysicalMemory * 0.75)
			If ($iMemPoolMax -gt 2GB)
			{$iMemPoolMax = 2GB}
		}
  }
  
  'WINDOWS 7 64-BIT'
  {
	  #// 75 percent of RAM or 128 GB, whichever is smaller
	  $iMemPoolMax = ($iPhysicalMemory * 0.75)
	  If ($iMemPoolMax -gt 128GB)
	  {$iMemPoolMax = 128GB}
  }
  
	'WINDOWS SERVER 2008 R2 64-BIT'
	{
		#// 75 percent of RAM or 128 GB, whichever is smaller
		$iMemPoolMax = ($iPhysicalMemory * 0.75)
		If ($iMemPoolMax -gt 128GB)
		{$iMemPoolMax = 128GB}
	}
  
  'WINDOWS 8 32-BIT'
  {
	  If ($UserVa -gt 2048) #// If /3GB
	  {
		  #// 75 percent of RAM or KernelVa size, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  $iKernelVa = (4096 - $UserVa) * 1MB
		  If ($iKernelVa -lt $iMemPoolMax)
		  {$iMemPoolMax = $iKernelVa}
	  }
	  Else 
	  {
		  #// 75 percent of RAM or 2 GB, whichever is smaller
		  $iMemPoolMax = ($iPhysicalMemory * 0.75)
		  If ($iMemPoolMax -gt 2GB)
		  {$iMemPoolMax = 2GB}
	  }
  }
  
	default
	{
		#// 75 percent of RAM or 128 GB, whichever is smaller
		$iMemPoolMax = ($iPhysicalMemory * 0.75)
		If ($iMemPoolMax -gt 128GB)
		{$iMemPoolMax = 128GB}
	}
}

$EightyPercentOfMemoryPoolMaximum = ($iMemPoolMax * 0.80)
StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -MinThreshold $EightyPercentOfMemoryPoolMaximum -MaxThreshold $iMemPoolMax -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 10% of physical memory usage by Pool Paged" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[

If ($PhysicalMemory -eq 0) {$PhysicalMemory = 1};
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
$iPhysicalMemory = $iPhysicalMemory * 1GB
$iTenPercentOfPhysicalMemory = $iPhysicalMemory * 0.10

StaticThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -Operator 'gt' -Threshold $iTenPercentOfPhysicalMemory
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.<BR>
<BR>
This analysis checks to see if the system is becoming close to the maximum Pool Nonpaged memory size. It does this by estimating the pool sizes taking into consideration /3GB, physical memory size, and 32-bit/64-bit, then determining if the value is higher than 60% of the estimated pool size. If the system becomes close to the maximum size, then the system could experience system wide hangs. Checks both 32-bit and 64-bit memory pools. Warning: The /3GB switch option in the boot.ini file significantly reduces the size of this memory pool.<BR>
<BR>
If the system is low on Paged Pool or non-Paged pool memory, then it is recommended to open a support case with Microsoft to address this. Alternatively, you can use a free and public tool called Poolmon.exe to see what DLL's are using kernel memory (see the article below). Most kernel memory leaks can be tracked back to a usermode process. To identify which user mode process is responsible, reboot the system (so you start off with a clean system), start a performance monitor log intending to run for a week or more capturing the Memory and Process objects, then analyze the perfmon log looking for memory leaks and/or handle leaks in one or more of the processes. In any case, migrating to a 64-bit version of Windows should alleviate this issue.
<BR>
<BR>
<B>References</B><BR>
How to Use Memory Pool Monitor (Poolmon.exe) to Troubleshoot Kernel Mode Memory Leaks<BR>
<A HREF="http://support.microsoft.com/kb/177415">http://support.microsoft.com/kb/177415</A><BR>
<BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pool Paged Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pool Paged Bytes" ID="{904560fe-0629-40ed-8514-cb9fbb8dd426}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pool Paged Bytes" COLLECTIONVARNAME="MemoryPoolPagedBytes" EXPRESSIONPATH="\Memory\Pool Paged Bytes" DATATYPE="Integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Commit Limit" EXPRESSIONPATH="\Memory\Commit Limit" COLLECTIONVARNAME="CollectionOfMemoryCommitLimit" DATATYPE="integer" />
    <THRESHOLD NAME="More than 60% of Pool Paged Kernel Memory Used" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE>
      <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()
	switch ($OS)
	{
		'WINDOWS XP 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS XP 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
		'WINDOWS SERVER 2003 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS SERVER 2003 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
    
		'WINDOWS VISTA 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
    'WINDOWS VISTA 64-BIT'
    {
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
		}
    
		'WINDOWS SERVER 2008 64-BIT'
		{
		  #// 128 GB or system commit limit whichever is smaller
		  $iMemPoolMax = 128GB
		}

    'WINDOWS 7 32-BIT'
    {
		  If ($UserVa -gt 2048) #// If /3GB
		  {
			  #// 2 GB or system commit limit, or KernelVa, whichever is smaller
			  $iMemPoolMax = 2GB
			  $iKernelVa = (4096 - $UserVa) * 1MB
			  If ($iKernelVa -lt $iMemPoolMax)
			  {$iMemPoolMax = $iKernelVa}
		  }
		  Else 
		  {
			  #// 2 GB or system commit limit, whichever is smaller
			  $iMemPoolMax = 2GB
		  }
    }
    
    'WINDOWS 7 64-BIT'
    {
	    #// 128 GB or system commit limit whichever is smaller
	    $iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 R2 64-BIT'
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
    
    'WINDOWS 8 32-BIT'
    {
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
		default
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
	}

$SixtyPercentOfMemoryPoolMaximum = $iMemPoolMax * 0.60
StaticThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -Operator 'gt' -Threshold $SixtyPercentOfMemoryPoolMaximum

         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% of Pool Paged Kernel Memory Used" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE>
      <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()
	switch ($OS)
	{
		'WINDOWS XP 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS XP 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
		'WINDOWS SERVER 2003 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS SERVER 2003 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
    
		'WINDOWS VISTA 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
    'WINDOWS VISTA 64-BIT'
    {
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
		}
    
		'WINDOWS SERVER 2008 64-BIT'
		{
		  #// 128 GB or system commit limit whichever is smaller
		  $iMemPoolMax = 128GB
		}

    'WINDOWS 7 32-BIT'
    {
		  If ($UserVa -gt 2048) #// If /3GB
		  {
			  #// 2 GB or system commit limit, or KernelVa, whichever is smaller
			  $iMemPoolMax = 2GB
			  $iKernelVa = (4096 - $UserVa) * 1MB
			  If ($iKernelVa -lt $iMemPoolMax)
			  {$iMemPoolMax = $iKernelVa}
		  }
		  Else 
		  {
			  #// 2 GB or system commit limit, whichever is smaller
			  $iMemPoolMax = 2GB
		  }
    }
    
    'WINDOWS 7 64-BIT'
    {
	    #// 128 GB or system commit limit whichever is smaller
	    $iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 R2 64-BIT'
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
    
    'WINDOWS 8 32-BIT'
    {
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
		default
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
	}

$EightyPercentOfMemoryPoolMaximum = $iMemPoolMax * 0.80
StaticThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -Operator 'gt' -Threshold $EightyPercentOfMemoryPoolMaximum
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Pool Paged Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Pool Paged Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE>
      <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()
	switch ($OS)
	{
		'WINDOWS XP 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
    
		'WINDOWS XP 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
		'WINDOWS SERVER 2003 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS SERVER 2003 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
    
		'WINDOWS VISTA 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
    'WINDOWS VISTA 64-BIT'
    {
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
		}
    
		'WINDOWS SERVER 2008 64-BIT'
		{
		  #// 128 GB or system commit limit whichever is smaller
		  $iMemPoolMax = 128GB
		}

    'WINDOWS 7 32-BIT'
    {
		  If ($UserVa -gt 2048) #// If /3GB
		  {
			  #// 2 GB or system commit limit, or KernelVa, whichever is smaller
			  $iMemPoolMax = 2GB
			  $iKernelVa = (4096 - $UserVa) * 1MB
			  If ($iKernelVa -lt $iMemPoolMax)
			  {$iMemPoolMax = $iKernelVa}
		  }
		  Else 
		  {
			  #// 2 GB or system commit limit, whichever is smaller
			  $iMemPoolMax = 2GB
		  }
    }
    
    'WINDOWS 7 64-BIT'
    {
	    #// 128 GB or system commit limit whichever is smaller
	    $iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 R2 64-BIT'
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
    
    'WINDOWS 8 32-BIT'
    {
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
		default
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
	}

$SixtyPercentOfPoolPagedMax = $iMemPoolMax * 0.60
$EightyPercentOfPoolPagedMax = $iMemPoolMax * 0.80
StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -MinThreshold $SixtyPercentOfPoolPagedMax -MaxThreshold $EightyPercentOfPoolPagedMax -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE>
  <![CDATA[
$iPhysicalMemory = $([Math]::Round($PhysicalMemory,0))
If ($iPhysicalMemory -eq 0)
{$iPhysicalMemory = 1}
$iPhysicalMemory = $iPhysicalMemory * 1GB
$OS = [string] $OS.ToUpper()
	switch ($OS)
	{
		'WINDOWS XP 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS XP 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
		'WINDOWS SERVER 2003 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB and DynamicMemory of 1 TB assumed
			{$iMemPoolMax = 158 * 1MB}
			Else
			{
				#// No /3GB and DynamicMemory of 1 TB assumed
				If ($iPhysicalMemory -le 1GB)
				{$iMemPoolMax = 168 * 1MB}
				Else {$iMemPoolMax = 354 * 1MB}
			}
    }
		'WINDOWS SERVER 2003 64-BIT'
		{
      switch ($($iPhysicalMemory))
      {
        1 {$iMemPoolMax = 3564MB}		
        2 {$iMemPoolMax = 3564MB}
        3 {$iMemPoolMax = 3564MB}
        4 {$iMemPoolMax = 5837MB}
        5 {$iMemPoolMax = 5837MB}
        6 {$iMemPoolMax = 5837MB}
        7 {$iMemPoolMax = 5837MB}
        8 {$iMemPoolMax = 12657MB}
        9 {$iMemPoolMax = 12657MB}
        10 {$iMemPoolMax = 12657MB}
        11 {$iMemPoolMax = 12657MB}
        12 {$iMemPoolMax = 19364MB}
        13 {$iMemPoolMax = 19364MB}
        14 {$iMemPoolMax = 19364MB}
        15 {$iMemPoolMax = 19364MB}
        16 {$iMemPoolMax = 39496MB}
        17 {$iMemPoolMax = 39496MB}
        18 {$iMemPoolMax = 39496MB}
        19 {$iMemPoolMax = 39496MB}
        20 {$iMemPoolMax = 39496MB}
        21 {$iMemPoolMax = 39496MB}
        22 {$iMemPoolMax = 39496MB}
        23 {$iMemPoolMax = 39496MB}
        24 {$iMemPoolMax = 39496MB}
        25 {$iMemPoolMax = 39496MB}
        26 {$iMemPoolMax = 39496MB}
        27 {$iMemPoolMax = 39496MB}
        28 {$iMemPoolMax = 39496MB}
        29 {$iMemPoolMax = 39496MB}
        30 {$iMemPoolMax = 39496MB}
        31 {$iMemPoolMax = 39496MB}
        32 {$iMemPoolMax = 54180MB}
        default {$iMemPoolMax = 54180MB}
      }
		}
    
		'WINDOWS VISTA 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }
    
    'WINDOWS VISTA 64-BIT'
    {
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 32-BIT'
		{
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
		}
    
		'WINDOWS SERVER 2008 64-BIT'
		{
		  #// 128 GB or system commit limit whichever is smaller
		  $iMemPoolMax = 128GB
		}

    'WINDOWS 7 32-BIT'
    {
		  If ($UserVa -gt 2048) #// If /3GB
		  {
			  #// 2 GB or system commit limit, or KernelVa, whichever is smaller
			  $iMemPoolMax = 2GB
			  $iKernelVa = (4096 - $UserVa) * 1MB
			  If ($iKernelVa -lt $iMemPoolMax)
			  {$iMemPoolMax = $iKernelVa}
		  }
		  Else 
		  {
			  #// 2 GB or system commit limit, whichever is smaller
			  $iMemPoolMax = 2GB
		  }
    }
    
    'WINDOWS 7 64-BIT'
    {
	    #// 128 GB or system commit limit whichever is smaller
	    $iMemPoolMax = 128GB
    }

		'WINDOWS SERVER 2008 R2 64-BIT'
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
    
    'WINDOWS 8 32-BIT'
    {
			If ($UserVa -gt 2048) #// If /3GB
			{
				#// 2 GB or system commit limit, or KernelVa, whichever is smaller
				$iMemPoolMax = 2GB
				$iKernelVa = (4096 - $UserVa) * 1MB
				If ($iKernelVa -lt $iMemPoolMax)
				{$iMemPoolMax = $iKernelVa}
			}
			Else 
			{
				#// 2 GB or system commit limit, whichever is smaller
				$iMemPoolMax = 2GB
			}
    }

		default
		{
			#// 128 GB or system commit limit whichever is smaller
			$iMemPoolMax = 128GB
		}
	}

$EightyPercentOfPoolPagedMax = $iMemPoolMax * 0.80
StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -MinThreshold $EightyPercentOfPoolPagedMax -MaxThreshold $iMemPoolMax -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Pool Paged is greater than 1 GB" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -Operator 'gt' -Threshold 1GB]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis checks to see if the system is becoming close to the maximum Pool paged memory size. Pool Paged Bytes is the size, in bytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used.<BR>
<BR>
This analysis checks to see if the system is becoming close to the maximum Pool Paged memory size. It does this by estimating the pool sizes taking into consideration /3GB, physical memory size, and 32-bit/64-bit, then determining if the value is higher than 60% of the estimated pool size. If the system becomes close to the maximum size, then the system could experience system wide hangs. Checks both 32-bit and 64-bit memory pools. Warning: The /3GB switch option in the boot.ini file significantly reduces the size of this memory pool.<BR>
<BR>
If the system is low on Paged Pool or non-Paged pool memory, then it is recommended to open a support case with Microsoft to address this. Alternatively, you can use a free and public tool called Poolmon.exe to see what DLL's are using kernel memory (see the article below). Most kernel memory leaks can be tracked back to a usermode process. To identify which user mode process is responsible, reboot the system (so you start off with a clean system), start a performance monitor log intending to run for a week or more capturing the Memory and Process objects, then analyze the perfmon log looking for memory leaks and/or handle leaks in one or more of the processes. In any case, migrating to a 64-bit version of Windows should alleviate this issue.<BR>
<BR>
<B>Reference:</B><BR>
How to Use Memory Pool Monitor (Poolmon.exe) to Troubleshoot Kernel Mode Memory Leaks<BR>
<A HREF="http://support.microsoft.com/kb/177415">http://support.microsoft.com/kb/177415</A><BR>
<BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pages/sec" ID="{0956e8c1-c91e-4765-9e4e-541f8079f502}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pages/sec" COLLECTIONVARNAME="CollectionOfMemoryPagessec" EXPRESSIONPATH="\Memory\Pages/sec" DATATYPE="Integer" />
    <CHART CHARTTITLE="\Memory\Pages/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Pages/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryPagessec -MinThreshold 1000 -MaxThreshold 1999.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 1000 hard page faults per second - this only indicates 4 MB/s or more of disk activity which may or may not be related to page file(s)" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryPagessec -Operator 'gt' -Threshold 1000]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis checks Pages/sec (hard page faults) of more than 1000. Keep in mind that all hard page faults are counted in the pages/sec counter which may or may not be related to the page file(s). 
      According to Wikipedia, memory-mapped files are a segment of virtual memory which has been assigned a direct byte-for-byte correlation with some portion of a file or file-like resource. This resource is typically a file that is physically present on-disk, but can also be a device, shared memory object, or other resource that the operating system can reference through a file descriptor.
In other words, applications like Microsoft Word and Microsoft PowerPoint will not load entire documents into RAM. Instead, they memory map the file, so that when you navigate through the document, it loads portions of the document as needed. The act of loading portions of the document from disk to RAM as a memory mapped file causes a hard page fault which is counted in the pages/sec counter. See the article <A HREF="http://blogs.technet.com/clinth/archive/2009/07/16/the-case-of-the-phantom-hard-page-faults.aspx">The Case of the Phantom Hard Page Faults</A>. To determine if the hard page faults are actually hitting the page file, use Process Monitor with Advanced Ouput enabled to see how often the page file(s) are hit.<BR> 
Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.<BR>
<BR>
This counter should always be below 1000, therefore this analysis checks for values above 1000. Use this analysis in correlation with Available Memory Analysis and Memory Leak Analysis. If all are throwing alerts at the same time, then this may indicate the system is running out of memory and the suspected processes involved and follow analysis steps mentioned in the Memory Leak analysis.<BR>
<BR>
<B>Reference</B><BR>
<UL>
<LI><A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">Ruling Out Memory-Bound Problems<BR></A></LI>
<LI><A HREF="http://blogs.technet.com/clinth/archive/2009/07/16/the-case-of-the-phantom-hard-page-faults.aspx">The Case of the Phantom Hard Page Faults<BR></A></LI>
</UL>
<BR>
      ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Working Set" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Working Set" ID="{e32af772-a24e-4a01-abe8-cd4f9d98253a}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Working Set" COLLECTIONVARNAME="ProcessWorkingSetTotal" EXPRESSIONPATH="\Process(_Total)\Working Set" DATATYPE="integer" />
    <THRESHOLD NAME="Increasing trend of more than 100 MB per hour - may not be accurate on counter logs of less than 1 hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $ProcessWorkingSetTotal -Operator 'gt' -Threshold 100MB -IsTrendOnly $True
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Process(_Total)\Working Set" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Working Set" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Working Set is the current size, in bytes, of the Working Set of a process. The Working Set is the set of memory pages touched recently by the threads in the process. It is the amount of RAM consumbed by each process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.<BR>
This analysis checks for an increasing trend of 100 MB or more per hour in all of the processes combined. This could be an aggressive working set (RAM usage) leak, but keep in mind that this is only tracking the amount of RAM used by all of the processes and does not include committed memory that has been paged out. This is why Private Bytes is a better counter to use for general memory leaks. With that said, Working Set is a helpful counter to have. Use this analysis in correlation with Available Memory Analysis.<BR>
<BR>
<B>Reference:</B><BR>
<UL>
<LI><A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">Ruling Out Memory-Bound Problems<BR></A></LI>
<LI><A HREF="http://blogs.technet.com/clinth/archive/2009/07/07/the-case-of-the-out-of-memory-biztalk-server.aspx">The Case of the Out of Memory BizTalk Server</A></LI>
</UL>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory System Cache Resident Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\System Cache Resident Bytes" ID="{11674a2f-1d1f-42ac-910b-2e6aa50cee79}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\System Cache Resident Bytes" COLLECTIONVARNAME="CollectionOfMemorySystemCacheResidentBytes" EXPRESSIONPATH="\Memory\System Cache Resident Bytes" DATATYPE="integer" />
    <THRESHOLD NAME="System Cache Resident Bytes is consumsing more than 10 percent of RAM" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[$TenPercentOfPhysicalMemory = $([Int]$PhysicalMemory * 1GB) * 0.10
StaticThreshold -CollectionOfCounterInstances $CollectionOfMemorySystemCacheResidentBytes -Operator 'gt' -Threshold $TenPercentOfPhysicalMemory]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\System Cache Resident Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\System Cache Resident Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          $TenPercentOfPhysicalMemory = $([Int]$PhysicalMemory * 1024 * 1024 * 1024) * 0.10
          $FiftyPercentOfPhysicalMemory = $([Int]$PhysicalMemory * 1024 * 1024 * 1024) * 0.50
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemorySystemCacheResidentBytes -MinThreshold $TenPercentOfPhysicalMemory -MaxThreshold $FiftyPercentOfPhysicalMemory -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[System Cache Resident Bytes is the size, in bytes, of the pageable operating system code in the file system cache. This value includes only current physical pages and does not include any virtual memory pages not currently resident. It does equal the System Cache value shown in Task Manager. As a result, this value may be smaller than the actual amount of virtual memory in use by the file system cache. This value is a component of Memory\\System Code Resident Bytes which represents all pageable operating system code that is currently in physical memory. This counter displays the last observed value only; it is not an average.<BR>
<BR>
This analysis checks if System Cache Resident Bytes is consuming more than 25 percent of RAM. Under load, a server might use the System Cache in order to cache I/O activity such as disk. Use in correlation with Process IO Data Operations/sec and Process IO Other Operations/sec Analyses.<BR>
<BR>
<B>References</B><BR>
File Cache Performance and Tuning http://technet.microsoft.com/en-us/library/bb742613.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Paging File % Usage" ENABLED="True" CATEGORY="Paging File" PRIMARYDATASOURCE="\Paging File(*)\% Usage" ID="{9d4009d1-8698-44a4-83d9-2bc77b01094f}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Paging File(*)\% Usage" COLLECTIONVARNAME="PagingFilePercentUsageALL" EXPRESSIONPATH="\Paging File(*)\% Usage" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 70% Page file usage" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -Operator 'gt' -Threshold 70
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 90% Page file usage" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -Operator 'gt' -Threshold 90
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Paging File(*)\% Usage" ISTHRESHOLDSADDED="True" DATASOURCE="\Paging File(*)\% Usage" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -MinThreshold 70 -MaxThreshold 90 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -MinThreshold 90 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[The amount of the Page File instance in use in percent.  See also Process\\Page File Bytes.<BR>
<BR>
This analysis checks if the percentage of usage is greater than 70%.<BR>
<BR>
<B>Reference</B><BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory % Committed Bytes In Use" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\% Committed Bytes In Use" ID="{f1b3e1f5-274b-488b-9982-b54b3e5d7ee5}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\% Committed Bytes In Use" COLLECTIONVARNAME="MemoryPercentCommittedBytesInUse" EXPRESSIONPATH="\Memory\% Committed Bytes In Use" DATATYPE="integer" />
    <THRESHOLD NAME="More than 80% the Commit Limit is in use" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -Operator 'gt' -Threshold 80
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 90% the Commit Limit is in use" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -Operator 'gt' -Threshold 90
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\% Committed Bytes In Use" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\% Committed Bytes In Use" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -MinThreshold 70 -MaxThreshold 90 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -MinThreshold 90 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Committed Bytes In Use is the ratio of Memory\Committed Bytes to the Memory\Commit Limit. Committed memory is the physical memory (RAM plus all of the page files) in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is the sum of physical RAM and the size of all of the paging files.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.<BR>
<BR>
This analysis checks if the amount of Commited memory is becoming close to the Commit Limit (RAM plus total page file sizes), If so, then identify if you have a memory leak. If no memory leak is identified, then consider adding more physical RAM or increase the size of your page files..<br>
<br>
The following article covers how to identify and troubleshoot system committed memory problems:<br>
<A HREF="http://social.technet.microsoft.com/wiki/contents/articles/2248.perfguide-out-of-system-committed-memory.aspx">PerfGuide: Out of System Committed Memory</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Disk Transfers/sec" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Transfers/sec" ID="{c72eb5e3-1d3f-4de7-9a04-cce57b59fa3c}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Transfers/sec" COLLECTIONVARNAME="LogicalDiskDiskTransferssecALL" EXPRESSIONPATH="\LogicalDisk(*)\Disk Transfers/sec" MINVARNAME="MinLogicalDisk_DiskTransferssec" AVGVARNAME="AvgLogicalDisk_DiskTransferssec" MAXVARNAME="MaxLogicalDisk_DiskTransferssec" TRENDVARNAME="TrendLogicalDisk_DiskTransferssec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Transfers/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Transfers/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Disk Transfers/sec is the rate of read and write operations on the disk and is the number of IO operations per second (IOPS) according to the operating system. If hardware RAID is used, then keep in mind that the hardware IOPS will be different. For example, hardware RAID1 (mirror set) will have hardware IOPS of (1 x Read) + (2 x Write).]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Server Pool Nonpaged Failures" ENABLED="True" CATEGORY="Server" PRIMARYDATASOURCE="\Server\Pool Nonpaged Failures" ID="{df1afb2e-810f-402d-9615-48656add7e40}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Server\Pool Nonpaged Failures" COLLECTIONVARNAME="ServerPoolNonpagedFailures" EXPRESSIONPATH="\Server\Pool Nonpaged Failures" DATATYPE="integer" />
    <CHART CHARTTITLE="\Server\Pool Nonpaged Failures" ISTHRESHOLDSADDED="False" DATASOURCE="\Server\Pool Nonpaged Failures" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[The number of times allocations from nonpaged pool have failed.  Indicates that the computer's physical memory is too small.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Server Pool Paged Failures" ENABLED="True" CATEGORY="Server" PRIMARYDATASOURCE="\Server\Pool Paged Failures" ID="{5f8fefaf-0d9c-42aa-836b-d2bef0a5f08d}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Server\Pool Paged Failures" COLLECTIONVARNAME="ServerPoolPagedFailures" EXPRESSIONPATH="\Server\Pool Paged Failures" DATATYPE="integer" />
    <CHART CHARTTITLE="\Server\Pool Paged Failures" ISTHRESHOLDSADDED="False" DATASOURCE="\Server\Pool Paged Failures" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[The number of times allocations from paged pool have failed.  Indicates that the computer's physical memory or paging file are too small.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages Output/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pages Output/sec" ID="{f77c4131-a0e5-4573-9fe1-212f3466f537}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pages Output/sec" COLLECTIONVARNAME="MemoryPagesOutputsec" EXPRESSIONPATH="\Memory\Pages Output/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pages Output/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Pages Output/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows writes more pages back to disk to free up space when physical memory is in short supply.  This counter shows the number of pages, and can be compared to other counts of pages, without conversion.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Transition Pages RePurposed/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Transition Pages RePurposed/sec" ID="{36d93462-3e5a-42b9-aab6-ea33082caae9}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Transition Pages RePurposed/sec" COLLECTIONVARNAME="MemoryTransitionPagesRePurposedsec" EXPRESSIONPATH="\Memory\Transition Pages RePurposed/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Transition Pages RePurposed/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Transition Pages RePurposed/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Transition Pages RePurposed is the rate at which the number of transition cache pages were reused for a different purpose.  These pages would have otherwise remained in the page cache to provide a (fast) soft fault (instead of retrieving it from backing store) in the event the page was accessed in the future.  Note these pages can contain private or sharable memory.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Outbound Errors" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets Outbound Errors" ID="{d2572721-c446-4331-a0c6-06319be62169}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets Outbound Errors" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketsOutboundErrorsALL" EXPRESSIONPATH="\Network Interface(*)\Packets Outbound Errors" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Network Interface Packet Errors occurring" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfacePacketsOutboundErrorsALL -Operator 'gt' -Threshold 1
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Network Interface(*)\Packets Outbound Errors" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\Packets Outbound Errors" CHARTLABELS="instance">
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfacePacketsOutboundErrorsALL -MinThreshold 1 -MaxThreshold 1.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.<BR>
<BR>
If errors are occuring during this analysis, network connectivity could be affected with a potential for random Outlook RPC dialog boxes. See <A HREF="http://technet.microsoft.com/en-us/library/aa997363.aspx">http://technet.microsoft.com/en-us/library/aa997363.aspx</A> and <A HREF="http://technet.microsoft.com/en-us/library/aa995850.asp">http://technet.microsoft.com/en-us/library/aa995850.asp</A> for more information<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Committed Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Committed Bytes" ID="{edc8cfd9-e14b-4d5b-b5c1-cbb4a73e90ae}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Committed Bytes" COLLECTIONVARNAME="CollectionOfMemoryCommittedBytes" EXPRESSIONPATH="\Memory\Committed Bytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Committed Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Committed Bytes" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the memory which has space reserved in RAM and on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.<BR>
    This analysis checks if the amount of total committed memory (Commit Charge) exceeds the amount of physical RAM installed. If so, the page file needs to be used to help store the committed memory and performance might degrade. To alleviate this, try to identify which process is consuming the most committed memory by looking at process Private Bytes and looking for a potential memory leak (the consumption of memory over a long period of time without releasing it). Adding more RAM to the computer will help alleviate this issue, but if it is a memory leak, then the problem might return.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Read/Write Ratio" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Reads/sec" ID="{c5bc515f-da40-4aa6-8341-2596347a5c5b}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Reads/sec" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskReadsPerSec" EXPRESSIONPATH="\LogicalDisk(*)\Disk Reads/sec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Writes/sec" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskWritesPerSec" EXPRESSIONPATH="\LogicalDisk(*)\Disk Writes/sec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\LogicalDisk(*)\Read Write Ratio" EXPRESSIONPATH="\LogicalDisk(*)\Read Write Ratio" COLLECTIONVARNAME="CollectionOfPalGeneratedReadWriteRatio" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedReadWriteRatio = @{}
          For ($i=0;$i -lt $CollectionOfLogicalDiskDiskReadsPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfLogicalDiskDiskWritesPerSec.Count;$a++)
            {
              If ($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterInstance -eq $CollectionOfLogicalDiskDiskWritesPerSec[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfLogicalDiskDiskReadsPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfLogicalDiskDiskReadsPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfLogicalDiskDiskWritesPerSec[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfReadsToWrites = ([double]$CollectionOfLogicalDiskDiskReadsPerSec[$i].QuantizedAvg[$v] / ([double]$CollectionOfLogicalDiskDiskReadsPerSec[$i].QuantizedAvg[$v] + [double]$CollectionOfLogicalDiskDiskWritesPerSec[$b].QuantizedAvg[$v])) * 100
                [void] $alValues.Add($iPercentageOfReadsToWrites)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterComputer)\$($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterObject)($($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterInstance))\Read Write Ratio"
            $CollectionOfPalGeneratedReadWriteRatio.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Read Write Ratio" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Read Write Ratio" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Reads/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Reads/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Writes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Writes/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[
    This analysis shows the ratio of reads to writes for each logical disk. For example, a value of 25 means 25 percent of all of the I/O per second is read I/O and 75 percent is write I/O.
    ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Bytes/Read" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Read" ID="{395c9f00-777d-4860-bd73-0c1464beb513}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Bytes/Read" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskBytesPerRead" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Bytes/Read" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk Bytes/Read" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Read" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than or equal to 64 KB IO sizes. Generally, the larger the IO size, the more data can be transferred per second, but the response times are longer." CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskBytesPerRead -Operator 'ge' -Threshold 65536]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis shows the size of logical disk reads per second. The size of an I/O request packets (IRP) can have a direct affect on the average response times from the disk. This analysis checks for I/O request sizes of 64 KB or larger. Correlate this analysis with the <B>Avg. Disk Sec/Read</B> and <B>Avg. Disk Sec/Write</B> analyses.<BR>
<BR>
References:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Bytes/Write" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Write" ID="{4d4bd0b0-2b5e-498f-8c8c-a03eb885a102}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Bytes/Write" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskBytesPerWrite" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Bytes/Write" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk Bytes/Write" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Write" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than or equal to 64 KB IO sizes. Generally, the larger the IO size, the more data can be transferred per second, but the response times are longer." CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskBytesPerWrite -Operator 'ge' -Threshold 65536]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis shows the size of logical disk writes per second. The size of an I/O request packets (IRP) can have a direct affect on the average response times from the disk. This analysis checks for I/O request sizes of 64 KB or larger. Correlate this analysis with the <B>Avg. Disk Sec/Read</B> and <B>Avg. Disk Sec/Write</B> analyses.<BR>
<BR>
Reference:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <!--
  <ANALYSIS NAME="PlaceHolder" ENABLED="True" CATEGORY="PlaceHolder" PRIMARYDATASOURCE="PlaceHolder"  ID="PlaceHolder">
    <DATASOURCE TYPE="CounterLog" NAME="PlaceHolder" EXPRESSIONPATH="PlaceHolder" COLLECTIONVARNAME="CollectionOf" DATATYPE="Integer" />
    <CHART CHARTTITLE="PlaceHolder" ISTHRESHOLDSADDED="True" DATASOURCE="PlaceHolder" CHARTLABELS="instance">
      <SERIES NAME="Warning" TYPE="Line" COLLECTIONMINVARNAME="MinWarningSeriesCollection" COLLECTIONMAXVARNAME="MaxWarningSeriesCollection" >
        <CODE>
          <![CDATA[          
          ForEach ($InstanceOfPlaceHolder in $CollectionOfPlaceHolder)
          {
            ForEach ($iValue in $InstanceOfPlaceHolder.Value)
            {
              [void] $MinWarningSeriesCollection.Add(75)
              [void] $MaxWarningSeriesCollection.Add(90)
            }
          }
        ]]>
        </CODE>
      </SERIES>
      <SERIES NAME="Critical" TYPE="Line" COLLECTIONMINVARNAME="MinCriticalSeriesCollection" COLLECTIONMAXVARNAME="MaxCriticalSeriesCollection" >
        <CODE>
          <![CDATA[
          ForEach ($InstanceOfPlaceHolder in $CollectionOfPlaceHolder)
          {
            ForEach ($iValue in $InstanceOfPlaceHolder.Value)
            {
              [void] $MinCriticalSeriesCollection.Add(90)
              [void] $MaxCriticalSeriesCollection.Add(99.99)
            }
          }
        ]]>
        </CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
  </ANALYSIS>
-->
  <ANALYSIS NAME="PhysicalDisk Current Disk Queue Length" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Current Disk Queue Length" ID="0cd5788d-1855-42c2-b2ce-9eee52411c72" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Current Disk Queue Length" COLLECTIONVARNAME="CollectionOfPhysicalDiskCurrentDiskQueueLength" EXPRESSIONPATH="\PhysicalDisk(*)\Current Disk Queue Length" TRENDVARNAME="TrendPhysicalDiskCurrentDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Current Disk Queue Length" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Current Disk Queue Length" CHARTLABELS="instance" />
    <THRESHOLD NAME="Experimental: HBA Queue Depth might be restricted to 32 - Consider increasing the HBA queue depth if applicable" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfPhysicalDiskCurrentDiskQueueLength -Operator 'ge' -Threshold 32]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.<BR>
<BR>
If the server is using an HBA (Host Bus Adapter: This is used to connect to a Storage Area Network SAN) and if the Current Disk Queue Length goes up to 32 frequently, then consider increasing the queue depth on the HBA to allow more concurrent I/O to the SAN. Please consult your SAN administrator before making any changes.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Avg. Disk Queue Length" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk Queue Length" ID="f4902104-0539-4fb5-8dbc-b2b15c0ec060" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Queue Length" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskQueueLength" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Queue Length" TRENDVARNAME="TrendLogicalDiskAvgDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskQueueLength -MinThreshold 2 -MaxThreshold 9.999 -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 2 IOs are waiting on the logical disk" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskQueueLength -Operator 'gt' -Threshold 2]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk Queue Length is the average number of both read and write requests that were queued or "in-flight" for the selected disk during the sample interval.<BR>
<BR>
This counter typically has a threshold of number of spindles + 2. Due to disk virtualization, it is difficult to determine the true number of physical spindles behind a logical disk or LUN, therefore this threshold is not a direct indicator of a disk performance problem.<BR>
<BR>
This analysis uses a Warning alert for an average disk queue length greater than 2, but correlate this value with disk latency (Avg. Disk sec/Transfer).<BR>
<BR>
References:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % DPC Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% DPC Time" ID="93c6731f-1538-4f0d-8c52-b294e1592ac4" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% DPC Time" COLLECTIONVARNAME="CollectionOfProcessorPercentDPCTime" EXPRESSIONPATH="\Processor(*)\% DPC Time" TRENDVARNAME="TrendProcessorPercentDPCTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\% DPC Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% DPC Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentDPCTime -MinThreshold 10 -MaxThreshold 99.999 -UseMaxValue $False]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 10% time in Deferred Procedure Calls (DPC) - likely busy or poorly written drivers" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentDPCTime -Operator 'gt' -Threshold 10]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Commit Limit" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Commit Limit" ID="0e688e18-1edb-4ca5-9445-b17dbb37fd61" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Commit Limit" COLLECTIONVARNAME="CollectionOfMemoryCommitLimit" EXPRESSIONPATH="\Memory\Commit Limit" TRENDVARNAME="TrendMemoryCommitLimit" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Commit Limit" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Commit Limit" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s).  It is measured in bytes. Committed memory is the physical memory which has space reserved on the disk paging files. There can be one paging file on each logical drive). If the paging file(s) are be expanded, this limit increases accordingly.  This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Avg. Disk Queue Length" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Avg. Disk Queue Length" ID="51260b28-3103-4629-ac4d-08437f0170c1" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Avg. Disk Queue Length" COLLECTIONVARNAME="CollectionOfPhysicalDiskAvgDiskQueueLength" EXPRESSIONPATH="\PhysicalDisk(*)\Avg. Disk Queue Length" TRENDVARNAME="TrendPhysicalDiskAvgDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Avg. Disk Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\PhysicalDisk(*)\Avg. Disk Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPhysicalDiskAvgDiskQueueLength -MinThreshold 2 -MaxThreshold 4 -IsOperatorGreaterThan $True -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 2 I/O's are waiting on the physical disk" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfPhysicalDiskAvgDiskQueueLength -Operator 'gt' -Threshold 2]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Current Disk Queue Length" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Current Disk Queue Length" ID="421dfe15-2ff0-4f32-b319-505aed5e6dd5" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Current Disk Queue Length" COLLECTIONVARNAME="CollectionOfLogicalDiskCurrentDiskQueueLength" EXPRESSIONPATH="\LogicalDisk(*)\Current Disk Queue Length" TRENDVARNAME="TrendLogicalDiskCurrentDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Current Disk Queue Length" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Current Disk Queue Length" CHARTLABELS="instance" />
    <THRESHOLD NAME="Experimental: 32 or greater current disk IOs queued. If using an HBA, then consider adjusting the queue depth." CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskCurrentDiskQueueLength -Operator 'ge' -Threshold 32]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks.<BR>
<BR>
This analysis checks if the number of I/O request packets (IRPs) in the disk queue are at 32 or higher. Many SAN vendors use 32 as a default setting for the Host Bus Adapter (HBA) which interfaces into the fibre channel network to connect to one or more SANs. If the queue depth (simultaneous in-flight I/O)  is reached frequently, then the queue depth might need to be increased.<BR>
<BR>
Reference:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages Input/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pages Input/sec" ID="8448cabb-a4c6-4b2d-8beb-0427f284ad90" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pages Input/sec" COLLECTIONVARNAME="CollectionOfMemoryPagesInputsec" EXPRESSIONPATH="\Memory\Pages Input/sec" TRENDVARNAME="TrendMemoryPagesInputsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pages Input/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Pages Input/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than 1000 page inputs per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryPagesInputsec -Operator 'gt' -Threshold 1000]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of  Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation.

This analysis checks for more than 1000 page inputs per second. If there is a lot of page inputs per second, then it could be normal file I/O reading from the disk as memory mapped files, or it could be reading from the page file. This counter is not an indicator of a lack of memory condition unless there is a lot of memory pressure corresponding to this alert.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Free &amp; Zero Page List Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Free &amp; Zero Page List Bytes" ID="c7af5191-3b22-4479-9a1c-1c30684b95f1" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Free &amp; Zero Page List Bytes" COLLECTIONVARNAME="CollectionOfMemoryFree&amp;ZeroPageListBytes" EXPRESSIONPATH="\Memory\Free &amp; Zero Page List Bytes" TRENDVARNAME="TrendMemoryFree&amp;ZeroPageListBytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Free &amp; Zero Page List Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Free &amp; Zero Page List Bytes" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Free & Zero Page List Bytes is the amount of physical memory, in bytes, that is assigned to the free and zero page lists. This memory does not contain cached data. It is immediately available for allocation to a process or for system use. For a full explanation of the memory manager, refer to MSDN and/or the System Performance and Troubleshooting Guide chapter in the Windows Server 2003 Resource Kit.<BR>
<BR>
If the size of the Free and Zero page list is large, then it is a good indicator of too much RAM installed on the computer. A large amount of Free and Zero page list size is normal for computers that have been recently powered on or booted. As the system accesses the hard disk placing pages of memory into the working sets of processes, eventually many of those pages of memory will be discarded or paged out. When that happens, the memory is often placed on the Standby list. A large Standby list is preferable because it uses the extra RAM as a disk cache. Available memory is the sum of the Free, Zero, and Standby page lists, so a high amount of available memory with a low amount of Zero and Free is preferred because the system is using the extra RAM as disk cache.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Bytes Total/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Total/sec" ID="1f05beca-dd49-476f-92b2-f782944740d9" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Total/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesTotalsec" EXPRESSIONPATH="\Network Interface(*)\Bytes Total/sec" TRENDVARNAME="TrendNetworkInterfaceBytesTotalsec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\Network Interface(*)\Bytes Total/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Bytes Total/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % User Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% User Time" ID="5d6b712d-8483-4abe-aa47-2e7daa83695e" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% User Time" COLLECTIONVARNAME="CollectionOfProcessorPercentUserTime" EXPRESSIONPATH="\Processor(*)\% User Time" TRENDVARNAME="TrendProcessorPercentUserTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\% User Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor(*)\% User Time" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>% User Time</B> is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.<BR>

<BR>

This analysis provides statistics only. Threads running on a processor will be in either user mode measured using <B>% User Time</B> or in priviledge/kernel mode measured using <B>% Privileged Time</B>. High <B>% User Time</B> indicates a high amount of application code is being executed. This is desirable versus too much time in privileged mode. See the Processor <B>% Privileged Time</B> analysis for more information.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Cache Lazy Write Flushes/sec" ENABLED="True" CATEGORY="Cache" PRIMARYDATASOURCE="\Cache\Lazy Write Flushes/sec" ID="14aa1191-dcc9-4b35-a6bb-b5bdcadca9b3" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Cache\Lazy Write Flushes/sec" COLLECTIONVARNAME="CollectionOfCacheLazyWriteFlushessec" EXPRESSIONPATH="\Cache\Lazy Write Flushes/sec" TRENDVARNAME="TrendCacheLazyWriteFlushessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Cache\Lazy Write Flushes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Cache\Lazy Write Flushes/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 100 Lazy Write flushes/second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfCacheLazyWriteFlushessec -Operator 'gt' -Threshold 100]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Lazy Write Flushes/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred by each write operation.<BR>
<BR>
The lazy writer writes 20% of the dirty pages every second, but increases the number of lazy write flushes if it is unable to keep up with the rate of dirty pages.
<BR>
This analysis checks for more than 100 lazy write flushes/second which might indicate that the lazy writer is falling behind in writing to the disk.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Cache Dirty Pages" ENABLED="True" CATEGORY="Cache" PRIMARYDATASOURCE="\Cache\Dirty Pages" ID="ee5a30e9-d101-4a83-bce0-88f7a8759fc8" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Cache\Dirty Pages" COLLECTIONVARNAME="CollectionOfCacheDirtyPages" EXPRESSIONPATH="\Cache\Dirty Pages" TRENDVARNAME="TrendCacheDirtyPages" DATATYPE="integer" />
    <CHART CHARTTITLE="\Cache\Dirty Pages" ISTHRESHOLDSADDED="False" DATASOURCE="\Cache\Dirty Pages" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Total number of dirty pages on the system cache]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Disk Bytes/sec" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Bytes/sec" ID="3a533e62-26fc-4c00-b05d-0036d434913f" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Bytes/sec" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskBytessec" EXPRESSIONPATH="\LogicalDisk(*)\Disk Bytes/sec" TRENDVARNAME="TrendLogicalDiskDiskBytessec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Bytes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Bytes/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations. A mirror pair (RAID1) 7200 RPM disk drives can deliver roughly 20 MB per second throughput.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Disk Bytes/sec" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Disk Bytes/sec" ID="043cf51b-1fa0-4e28-86c3-cd0e6f12cc99" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Disk Bytes/sec" COLLECTIONVARNAME="CollectionOfPhysicalDiskDiskBytessec" EXPRESSIONPATH="\PhysicalDisk(*)\Disk Bytes/sec" TRENDVARNAME="TrendPhysicalDiskDiskBytessec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Disk Bytes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Disk Bytes/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information Parking Status" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\Parking Status" ID="7a14d59e-1aec-465f-bfad-6283bc2d9ad6" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\Parking Status" COLLECTIONVARNAME="CollectionOfProcessorInformationParkingStatus" EXPRESSIONPATH="\Processor Information(*)\Parking Status" TRENDVARNAME="TrendProcessorInformationParkingStatus" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\Parking Status" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor Information(*)\Parking Status" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationParkingStatus -MinThreshold 0.5 -MaxThreshold 0.999 -IsOperatorGreaterThan $True -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Processor is in a parked state" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationParkingStatus -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Parking Status represents whether a processor is parked or not.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % of Maximum Frequency" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% of Maximum Frequency" ID="dff534ed-4263-4a28-93a1-e14a94607594" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% of Maximum Frequency" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentofMaximumFrequency" EXPRESSIONPATH="\Processor Information(*)\% of Maximum Frequency" TRENDVARNAME="TrendProcessorInformationPercentofMaximumFrequency" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\Processor Information(*)\% of Maximum Frequency" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% of Maximum Frequency" CHARTLABELS="instance" />
    <THRESHOLD NAME="Processor is not running at its maximum clock speed" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentofMaximumFrequency -Operator 'lt' -Threshold 100]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% of Maximum Frequency is the percentage of the current processor's maximum frequency. An alert will be created if one or more processors are not running at 100% of their maximum frequency.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Free Megabytes" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Free Megabytes" ID="2e903f60-42e2-4760-9c52-38f8ba7c12e5" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Free Megabytes" COLLECTIONVARNAME="CollectionOfLogicalDiskFreeMegabytes" EXPRESSIONPATH="\LogicalDisk(*)\Free Megabytes" TRENDVARNAME="TrendLogicalDiskFreeMegabytes" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="HarddiskVolume1" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Free Megabytes" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Free Megabytes" CHARTLABELS="instance" />
    <THRESHOLD NAME="Less than 4 GB of free disk space" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskFreeMegabytes -Operator 'lt' -Threshold 4000]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 500 MB of free disk space" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskFreeMegabytes -Operator 'lt' -Threshold 500]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Free Megabytes displays the unallocated space, in megabytes, on the disk drive in megabytes. One megabyte is equal to 1,048,576 bytes.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor DPC Rate" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\DPC Rate" ID="0a22b344-a3f9-4445-bf62-7c429df68231" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\DPC Rate" COLLECTIONVARNAME="CollectionOfProcessorDPCRate" EXPRESSIONPATH="\Processor(*)\DPC Rate" TRENDVARNAME="TrendProcessorDPCRate" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\DPC Rate" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor(*)\DPC Rate" CHARTLABELS="instance">
    </CHART>
    <DESCRIPTION><![CDATA[DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Current Bandwidth" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Current Bandwidth" ID="48ae886e-4c85-4620-b15a-055b577da047" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" TRENDVARNAME="TrendNetworkInterfaceCurrentBandwidth" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Current Bandwidth" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Current Bandwidth" CHARTLABELS="instance" />
    <THRESHOLD NAME="Less than 1 Gbps connection" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceCurrentBandwidth -Operator 'lt' -Threshold 1000000000
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets/sec" ID="56ec51bc-6d8e-46b3-beb0-5bace1fdf247" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketssec" EXPRESSIONPATH="\Network Interface(*)\Packets/sec" TRENDVARNAME="TrendNetworkInterfacePacketssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Packets/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Packets/sec is the rate at which packets are sent and received on the network interface.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Sent/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets Sent/sec" ID="d5eed88b-db20-4baa-9ee7-9e462b610e5c" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets Sent/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketsSentsec" EXPRESSIONPATH="\Network Interface(*)\Packets Sent/sec" TRENDVARNAME="TrendNetworkInterfacePacketsSentsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets Sent/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Packets Sent/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Packets Sent/sec is the rate at which packets are sent on the network interface.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Received/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets Received/sec" ID="8fb77984-90c3-4c99-91d8-ab7e3599d561" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets Received/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketsReceivedsec" EXPRESSIONPATH="\Network Interface(*)\Packets Received/sec" TRENDVARNAME="TrendNetworkInterfacePacketsReceivedsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets Received/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Packets Received/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Packets Received/sec is the rate at which packets are received on the network interface.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Inspection System\Average inspection latency  Average inspection latency (sec/bytes)" ENABLED="True" CATEGORY="Network Inspection System" PRIMARYDATASOURCE="\Network Inspection System\Average inspection latency (sec/bytes)" ID="c9a15142-ba6f-40a8-976a-76854d77011d" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Inspection System\Average inspection latency (sec/bytes)" COLLECTIONVARNAME="CollectionOfNetworkInspectionSystemAverageinspectionlatencyAverageinspectionlatencysecbytes" EXPRESSIONPATH="\Network Inspection System\Average inspection latency (sec/bytes)" TRENDVARNAME="TrendNetworkInspectionSystemAverageinspectionlatencyAverageinspectionlatencysecbytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Inspection System\Average inspection latency (sec/bytes)" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Inspection System\Average inspection latency (sec/bytes)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Average time spent inspecting data (sec/bytes)]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="TCPv4 Connection Failures" ENABLED="True" CATEGORY="TCPv4" PRIMARYDATASOURCE="\TCPv4\Connection Failures" ID="02c86473-f7fe-4cb7-8eb3-f9a0625d982f" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\TCPv4\Connection Failures" COLLECTIONVARNAME="CollectionOfTCPv4ConnectionFailures" EXPRESSIONPATH="\TCPv4\Connection Failures" TRENDVARNAME="TrendTCPv4ConnectionFailures" DATATYPE="integer" />
    <CHART CHARTTITLE="\TCPv4\Connection Failures" ISTHRESHOLDSADDED="False" DATASOURCE="\TCPv4\Connection Failures" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 10 TCP connection failures per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[#// Use PowerShell code to create alerts when the conditions for this threshold are met.
#// Optionally use the variables listed above in the Variables list box.
#// If the condition for this threshold is a static value, then use the StaticThreshold() function.
#// Otherwise, you will need to manually loop through the counter instance collection object.
#// The counter instance collection object has a unique name for each counter data source in this analysis.
#// See the variables in the Variables list box above for more information on the counter instance collection object.

#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $CollectionOfTCPv4ConnectionFailures -Operator 'gt' -Threshold 10 -IsTrendOnly $True
  

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Long-Term Average Standby Cache Lifetime (s)" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Long-Term Average Standby Cache Lifetime (s)" ID="b376be4d-d803-43db-b2a0-21dc99cac1f7" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Long-Term Average Standby Cache Lifetime (s)" COLLECTIONVARNAME="CollectionOfMemoryLongTermAverageStandbyCacheLifetimeLongTermAverageStandbyCacheLifetimes" EXPRESSIONPATH="\Memory\Long-Term Average Standby Cache Lifetime (s)" TRENDVARNAME="TrendMemoryLongTermAverageStandbyCacheLifetimeLongTermAverageStandbyCacheLifetimes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Long-Term Average Standby Cache Lifetime (s)" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Long-Term Average Standby Cache Lifetime (s)" CHARTLABELS="instance" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryLongTermAverageStandbyCacheLifetimeLongTermAverageStandbyCacheLifetimes -MinThreshold 5000 -MaxThreshold 9999.999 -IsOperatorGreaterThan $False -UseMaxValue $False]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryLongTermAverageStandbyCacheLifetimeLongTermAverageStandbyCacheLifetimes -MinThreshold 0 -MaxThreshold 5000 -IsOperatorGreaterThan $False -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Standby page life expectancy is less than 10000 seconds" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryLongTermAverageStandbyCacheLifetimeLongTermAverageStandbyCacheLifetimes -Operator 'lt' -Threshold 10000]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Standby page life expectancy is less than 5000 seconds" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryLongTermAverageStandbyCacheLifetimeLongTermAverageStandbyCacheLifetimes -Operator 'lt' -Threshold 5000]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[A low Long-Term Standby cache lifetime might indicate a low physical memory condition when correlated with other memory related performance counters such as <B>\Memory\Available MBytes</B>, <B>\Memory\Page Writes/sec</B>, and disk related performance counters such as <B>\LogicalDisk(*)\Avg. Disk sec/Transfer.</B><BR>
<BR>
The <B>\Memory\Long-Term Average Standby Cache Lifetime (s)</B> performance counter measures the average lifetime in seconds of pages in the standby list cache over a long period of time. A low life expectancy could indicate that the pages on the standby list are frequently used i.e. the system has to replenish the standby list with pages from the modified list (pages that must be written to disk first) and the modified list is replenished by the working sets of processes.<BR>
<BR>
The Standby page list is a list of physical pages that are no longer in use (they are available to be reused), but contain data that already exists on disk. If the data is needed again, then it can be served from the Standby list in physical memory instead of going to disk to get it. Therefore, it is part of the system available memory and it acts as disk cache - the larger the disk cache, the less demand on the disk. ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % DPC Time" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% DPC Time" ID="1c8170c5-ba33-43e3-9f79-83d8791b3467" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% DPC Time" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentDPCTime" EXPRESSIONPATH="\Processor Information(*)\% DPC Time" TRENDVARNAME="TrendProcessorInformationPercentDPCTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\% DPC Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% DPC Time" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 10% time in Deferred Procedure Calls (DPC) - likely busy or poorly written drivers" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentDPCTime -Operator 'gt' -Threshold 10]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % Interrupt Time" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% Interrupt Time" ID="d862af79-71a1-4480-a739-76c55e8ca6a3" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% Interrupt Time" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentInterruptTime" EXPRESSIONPATH="\Processor Information(*)\% Interrupt Time" TRENDVARNAME="TrendProcessorInformationPercentInterruptTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\% Interrupt Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% Interrupt Time" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 5% Interrupt Time" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentInterruptTime -Operator 'gt' -Threshold 5]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 10% Interrupt Time" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentInterruptTime -Operator 'gt' -Threshold 10]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. suspends normal thread execution during interrupts. This counter displays the average busy time as a percentage of the sample time.<BR>
<BR>
This analysis checks for % Interrupt Time greater than 30%. If this occurs, then consider updating devices drivers for hardware that correlates to this alert.<BR>
<BR>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % Privileged Time" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% Privileged Time" ID="0f29fe91-025e-414d-ba06-4fda6d86a809" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% Privileged Time" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentPrivilegedTime" EXPRESSIONPATH="\Processor Information(*)\% Privileged Time" TRENDVARNAME="TrendProcessorInformationPercentPrivilegedTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\% Privileged Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% Privileged Time" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 20% privileged (kernel) mode CPU usage" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentPrivilegedTime -Operator 'gt' -Threshold 20]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 30% privileged (kernel) mode CPU usage" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentPrivilegedTime -Operator 'gt' -Threshold 30]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.<BR>
<BR>
High privileged mode CPU indicates that computer is spending too much time in system I/O versus real (user mode) work. % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.<BR>
<BR>
This analysis throws a warning alert if privileged mode CPU is consuming more than 20% of total CPU and a critical alert if consuming More than 30% of total CPU.<br>

<BR>
<B>Next steps</B><BR>
The CPU consumption might be caused by another busy resource such as network, memory, or disk I/O. High privileged mode CPU can also by caused by high amounts of Context Switches/second. See the High Context Switches/second analysis. The <A HREF="http://www.microsoft.com/whdc/system/sysperf/krview.mspx">KernRate (KrView) tool</A> can be used to profile the kernel to see what component is consuming the most kernel resources. To see more information about how KernRate can be used to analyze high priviledge mode CPU problems, see Mark Russinovich's blog entry in the references section below.<BR>
<BR>
<B>References:</B><BR>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://blogs.technet.com/markrussinovich/archive/2008/04/07/3031251.aspx">Mark's Blog : The Case of the System Process CPU Spikes</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % Processor Time" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% Processor Time" ID="32335f1c-0271-49d8-8a81-b2f2d2302010" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% Processor Time" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentProcessorTime" EXPRESSIONPATH="\Processor Information(*)\% Processor Time" TRENDVARNAME="TrendProcessorInformationPercentProcessorTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\% Processor Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% Processor Time" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 50% processor utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentProcessorTime -Operator 'gt' -Threshold 50]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% processor utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorInformationPercentProcessorTime -Operator 'gt' -Threshold 80]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the percentage of time that the processor spends executing the idle thread and then subtracting that value from 100%. (Each processor has an idle thread to which time is accumulated when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It should be noted that the accounting calculation of whether the processor is idle is performed at an internal sampling interval of the system clock tick. On todays fast processors, % Processor Time can therefore underestimate the processor utilization as the processor may be spending a lot of time servicing threads between the system clock sampling interval. Workload based timer applications are one example  of applications  which are more likely to be measured inaccurately as timers are signaled just after the sample is taken.<BR>
<BR>
This analysis creates a Warning alert for utilization greater than 50% on any processor and creates a critical alert for utilization greater than 80%.<BR>
<BR>

If average processor utilization is high based on the thresholds witin this analysis, then check if it is high user mode CPU or high privileged mode. If high privileged mode CPU is suspected, then see the Privileged Mode CPU Analysis. If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See <A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A> article in the references section for more information.
      <BR>
<B>References:</B>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A></LI>
</UL>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % User Time" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% User Time" ID="d5057ec6-7bb8-4bd0-ba07-c083f4736af0" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% User Time" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentUserTime" EXPRESSIONPATH="\Processor Information(*)\% User Time" TRENDVARNAME="TrendProcessorInformationPercentUserTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\% User Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% User Time" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[% User Time is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information DPC Rate" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\DPC Rate" ID="ccfacc44-cbd1-4f30-bbc9-2c91f2750271" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\DPC Rate" COLLECTIONVARNAME="CollectionOfProcessorInformationDPCRate" EXPRESSIONPATH="\Processor Information(*)\DPC Rate" TRENDVARNAME="TrendProcessorInformationDPCRate" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\DPC Rate" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\DPC Rate" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Physical Memory Overwhelmed" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Physical Memory Overwhelmed" ID="36031dde-a0f4-4833-acaa-3bd07f45af5b" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Available MBytes" COLLECTIONVARNAME="CollectionOfMemoryAvailableMBytes" EXPRESSIONPATH="\Memory\Available MBytes" TRENDVARNAME="TrendMemoryAvailableMBytes" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Paging File(*)\% Usage" EXPRESSIONPATH="\Paging File(*)\% Usage" COLLECTIONVARNAME="CollectionOfPagingFilePercentUsage" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Transfer" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Transfer" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDisksecTransferAll" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Bytes/Transfer" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Bytes/Transfer" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskBytesTransferAll" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Queue Length" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Queue Length" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskQueueLengthAll" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Memory\Physical Memory Overwhelmed" EXPRESSIONPATH="\Memory\Physical Memory Overwhelmed" COLLECTIONVARNAME="CollectionOfMemoryPhysicalMemoryOverwhelmed" DATATYPE="round2">
      <CODE><![CDATA[
$CollectionOfMemoryPhysicalMemoryOverwhelmed = @{}
$htPagingDiskOverwhelmedStatus = @{}
#// Populate the paging disk overwhelmed hash table
For ($a=0;$a -lt $CollectionOfPagingFilePercentUsage.Count;$a++)
{
    $sPagingFileDiskLetter = $CollectionOfPagingFilePercentUsage[$a].CounterInstance
    $sPagingFileDiskLetter = $sPagingFileDiskLetter -Replace('\\\?\?\\','')
    $sPagingFileDiskLetter = $sPagingFileDiskLetter -Replace('\\pagefile.sys','')
    [void] $htPagingDiskOverwhelmedStatus.Add($sPagingFileDiskLetter,0)
}

For ($a=0;$a -lt $CollectionOfMemoryAvailableMBytes.Count;$a++)
{
    $alValues = New-Object System.Collections.ArrayList
    $TenPercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1KB) * 0.10
    $FivePercentOfPhysicalMemory = $([Int] $PhysicalMemory * 1KB) * 0.05
    For ($v=0;$v -lt $CollectionOfMemoryAvailableMBytes[$a].Value.Count;$v++)
    {
        $iResult = 0
        If ($CollectionOfMemoryAvailableMBytes[$a].Value[$v] -lt $TenPercentOfPhysicalMemory)
        {
            If ($htPagingDiskOverwhelmedStatus.Count -eq 0)
            {
                #// No paging files
                $iResult = 1
                If ($CollectionOfMemoryAvailableMBytes[$a].Value[$v] -lt $FivePercentOfPhysicalMemory)
                {
                    $iResult = 2
                }
            }
            Else
            {
                #// Less than 10% available memory
                $iResult = 0
                #// ForEach key in paging disk is disk overwhelmed
                $oPfKeys = @($htPagingDiskOverwhelmedStatus.Keys)
                ForEach ($oPfKey in $oPfKeys)
                {
                    [Int]$QueueLengthMatch = -1;[Int]$BytesTransferMatch = -1;[Int]$SecPerTransferMatch = -1;
                    For ($i=0;$i -lt $CollectionOfLogicalDiskAvgDiskQueueLengthAll.Count;$i++)
                    {
                        If ($oPfKey -eq $CollectionOfLogicalDiskAvgDiskQueueLengthAll[$i].CounterInstance)
                        {
                            $QueueLengthMatch = $i
                        }
                    }
                    For ($i=0;$i -lt $CollectionOfLogicalDiskAvgDiskBytesTransferAll.Count;$i++)
                    {
                        If ($oPfKey -eq $CollectionOfLogicalDiskAvgDiskBytesTransferAll[$i].CounterInstance)
                        {
                            $BytesTransferMatch = $i
                        }
                    }
                    For ($i=0;$i -lt $CollectionOfLogicalDiskAvgDisksecTransferAll.Count;$i++)
                    {
                        If ($oPfKey -eq $CollectionOfLogicalDiskAvgDisksecTransferAll[$i].CounterInstance)
                        {
                            $SecPerTransferMatch = $i
                        }
                    }
                    If (($QueueLengthMatch -ge 0) -and ($BytesTransferMatch -ge 0) -and ($SecPerTransferMatch -ge 0))
                    {
                        If (($CollectionOfLogicalDiskAvgDiskQueueLengthAll[$QueueLengthMatch].Value[$v] -ge 1) -and ($CollectionOfLogicalDiskAvgDisksecTransferAll[$SecPerTransferMatch].Value[$v] -gt 0.015))
                        {
                            $iResult = 1
                            If ($CollectionOfLogicalDiskAvgDiskBytesTransferAll[$BytesTransferMatch].Value[$v] -gt 65536)
                            {
                                $ResponseTimeCriticalThreshold = 0.035
                            }
                            Else
                            {
                                $ResponseTimeCriticalThreshold = 0.025
                            }

                            If (($CollectionOfLogicalDiskAvgDiskQueueLengthAll[$QueueLengthMatch].Value[$v] -ge 1) -and ($CollectionOfLogicalDiskAvgDisksecTransferAll[$SecPerTransferMatch].Value[$v] -gt $ResponseTimeCriticalThreshold))
                            {
                                $iResult = 2
                            }
                        }
                    }
                    $htPagingDiskOverwhelmedStatus[$oPfKey] = $iResult
                }

                $iResult = 2
                ForEach ($oPfKey in $htPagingDiskOverwhelmedStatus.Keys)
                {
                    If ($htPagingDiskOverwhelmedStatus[$oPfKey] -eq 1)
                    {
                        $iResult = 1
                    }
                    If ($htPagingDiskOverwhelmedStatus[$oPfKey] -eq 0)
                    {
                        $iResult = 0
                    }
                }
            }
        }
        [void] $alValues.Add($iResult)
    }
    $sGeneratedInstanceName = "\\$($CollectionOfMemoryAvailableMBytes[$a].CounterComputer)\Memory\Physical Memory Overwhelmed"
    $CollectionOfMemoryPhysicalMemoryOverwhelmed.Add($sGeneratedInstanceName,$alValues)
}
        ]]></CODE>
    </DATASOURCE>
    <CHART CHARTTITLE="\Memory\Physical Memory Overwhelmed" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Physical Memory Overwhelmed" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryPhysicalMemoryOverwhelmed -MinThreshold 0.75 -MaxThreshold 1 -IsOperatorGreaterThan $True -UseMaxValue $False]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryPhysicalMemoryOverwhelmed -MinThreshold 1 -MaxThreshold 1.999 -IsOperatorGreaterThan $True -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="!!Experimental!! Available physical memory is less than 10%" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryPhysicalMemoryOverwhelmed -Operator 'ge' -Threshold 1]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="!!Experimental!! Physical memory is overwhelmed: Available memory is less than 5% and the disks hosting paging files are overwhelmed" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryPhysicalMemoryOverwhelmed -Operator 'ge' -Threshold 2]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[It's complicated... This analysis combines analysis of the disks hosting paging files and the availablility of physical memory. This is a beta test of it. Please provide feedback to me about this at Twitter @ClintH or at the forums at <A HREF="http://pal.codeplex.com">http://pal.codeplex.com</A>.<BR>
<BR>
This analysis gets the instances of <B>\Paging File(*)\% Usage</B> to identify the logical disks that are hosting paging files. Next, it checks each disk for an Avg. Disk Queue Length of greater than 1 when the <B>Avg. Disk sec/Transfer</B> (otherwise known as "response times") is greater than 15 ms. If true, then this counter returns the value 1 (warning). If the response times are greater than 25 ms and if the IO sizes are 64 KB or smaller, then it returns a 2 (critical). If the IO sizes (<B>Avg. Disk Bytes/Transfer</B>) are greater than 64 KB, then it returns a value of 2 (critical) only if the <B>Avg. Disk sec/Transfer</B> is greater than 35 ms. If none of the criteria is met, then it return a 0 (OK).
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="System System Calls/sec" ENABLED="True" CATEGORY="System" PRIMARYDATASOURCE="\System\System Calls/sec" ID="b899322c-5db2-48a1-b486-47eb2fedd8f7" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[System Calls/sec is the combined rate of calls to operating system service routines by all processes running on the computer. These routines perform all of the basic scheduling and synchronization of activities on the computer, and provide access to non-graphic devices, memory management, and name space management. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\System\System Calls/sec" COLLECTIONVARNAME="CollectionOfSystemSystemCallssec" EXPRESSIONPATH="\System\System Calls/sec" TRENDVARNAME="TrendSystemSystemCallssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\System\System Calls/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\System\System Calls/sec" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Avg. Disk sec/Transfer" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Transfer" ID="d84a6cb2-e9be-43d8-bdb1-1edca0c874bd" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Transfer" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDisksecTransfer" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Transfer" TRENDVARNAME="TrendLogicalDiskAvgDisksecTransfer" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Transfer" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Transfer" CHARTLABELS="instance" MAXLIMIT="0.099999">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDisksecTransfer -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDisksecTransfer -MinThreshold 0.025 -MaxThreshold 0.099999 -UseMaxValue $False]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Greater than 15 ms logical disk response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDisksecTransfer -Operator 'gt' -Threshold 0.015]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25 ms logical disk response times" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDisksecTransfer -Operator 'gt' -Threshold 0.025]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 600 ms logical disk response times - Floppy drive response times" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDisksecTransfer -Operator 'gt' -Threshold 0.6]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Transfer is the time, in seconds, of the average disk transfer.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pool Paged Resident Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pool Paged Resident Bytes" ID="d54468b7-7263-40ea-8559-31c609a42c60" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pool Paged Resident Bytes" COLLECTIONVARNAME="CollectionOfMemoryPoolPagedResidentBytes" EXPRESSIONPATH="\Memory\Pool Paged Resident Bytes" TRENDVARNAME="TrendMemoryPoolPagedResidentBytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pool Paged Resident Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Pool Paged Resident Bytes" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Pool Paged Resident Bytes is the size, in bytes, of the portion of the paged pool that is currently resident and active in physical memory. The paged pool is an area of the system virtual memory that is used for objects that can be written to disk when they are not being used. This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <INHERITANCE FILEPATH="" />
</PAL>
