<PAL NAME="Microsoft SQL Server 2008 / R2" DESCRIPTION="Performance counter thresholds for Microsoft SQL Server 2005/2008." CONTENTOWNERS="David Pless" FEEDBACKEMAILADDRESS="dpless@microsoft.com" VERSION="2.0" PALVERSION="2.0" LANGUAGE="English" LANGUAGECODE="en">
  <ANALYSIS NAME="Process % Privileged Time" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(sqlservr)\% Privileged Time" ID="{827ecf3b-78aa-4611-8262-438e85213ae8}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(sqlservr)\% Privileged Time" COLLECTIONVARNAME="CollectionOfProcessPercentPrivilegedTimesqlservr" EXPRESSIONPATH="\Process(sqlservr)\% Privileged Time" DATATYPE="integer" />
    <THRESHOLD NAME="SQL Server is using more than 20% privileged (kernel) mode CPU usage" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessPercentPrivilegedTimesqlservr -Operator 'gt' -Threshold 20        
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="SQL Server is using more than 30% privileged (kernel) mode CPU usage" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessPercentPrivilegedTimesqlservr -Operator 'gt' -Threshold 30
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Process(sqlservr)\% Privileged Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Process(sqlservr)\% Privileged Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessPercentPrivilegedTimesqlservr -MinThreshold 20 -MaxThreshold 30 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessPercentPrivilegedTimesqlservr -MinThreshold 30 -MaxThreshold 99.999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>\Process % Privileged Time / Process(sqlservr)\% Privileged Time</B>
<BR>
<BR>
<B>Description:</B> % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode. When a Windows system service is called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.
<BR><BR>
Privileged or kernel mode is the processing mode that allows code to have direct access to all hardware and memory in the system. I/O operations and other system services run in privileged (kernel) mode; user applications run in user mode. Unless the processes are graphics-intensive or I/O-intensive such as file and print services, most applications should not be processing much work in kernel mode.
Privileged mode corresponds to the percentage of time the processor spends on execution of Microsoft Windows kernel commands, such as processing of SQL Server I/O requests. If this counter is consistently high when the Physical Disk counters are high, consider focusing on improving the disk subsystem.
<BR>
It is recommended to look for comparitive trends with other processes, work loads, error counts, and other behaviors to find what is driving Privileged Time.
<BR><BR>
<B>Note:</B> Different disk controllers and drivers use different amounts of kernel processing time. Efficient controllers and drivers use less privileged time, leaving more processing time available for user applications, increasing overall throughput.
<BR>
<BR>
<B>Threshold:</B>
<BR>
<B>Yellow:</B> SQL Server is using more than 20% Privileged (kernel) mode CPU usage
<BR><B>Red:</B> SQL Server is using more than 30% Privileged (kernel) mode CPU usage
<BR><BR><B>Next Steps:</B>
The key piece to diagnosing high processor conditions is to determine the ratio of privileged mode to user mode CPU.
The counter '\Processor\% Processor Time' is the sum of '\Processor\% Privileged Time' and '\Processor\% User Time'. If Privileged Time is pushing the %Processor Time higher then it is due to processes executing in kernel mode. If '% User Time' is causing the % Processor Time to be higher then it is likely a user mode process that is causing the pressure.
If %Privileged Time is consistently high or shows high under load, it could be several issues. The most common reason for high %Privileged Time is disk pressure which can be measured by correlating this counter with Physical Disk reads / sec and Physical Disk writes / sec. If these are also high you may also see a high number of Page Latch Waits for SQL Server which can be measured by examining the sys.dm_os_wait_stats dynamic management view and the perfmon SQL Server:Wait Statistics perfmon counters. 
<BR>
If SQL Server Memory Manager: Page Life Expectancy is also low try to address by reducing the number of queries that are performing a high number of logical reads by adding indexes, ensuring that statistics are up to date, and potentially rewriting the query. 
<BR>
You could add more physical RAM to help raise Page Life Expectancy if it is low (lower than your baseline, or critical when under 300) although we only recommend adding memory as an absolute last resort. We first recommended addressing design and addressing poor indexing first. Adding physical RAM only masks the real issue.
<BR>
The other potential reasons for high privileged mode are related to out of date drivers, BIOS being out of date, failing components, processes that run in kernel mode such as anti-virus, and other potential issues.
<BR>
<B>Reference:</B>
<BR>
<B>Monitoring CPU Usage</B><BR>
http://msdn.microsoft.com/en-us/library/ms178072.aspx 
<BR><B>Ask the Performance Team</B>
http://blogs.technet.com/askperf/archive/2008/01/18/do-you-know-where-your-processor-spends-its-time.aspx 
<BR><B>Clint Huffman's Windows Troubleshooting in the Field Blog</B>
http://blogs.technet.com/clinth/archive/2009/10/28/the-case-of-the-2-million-context-switches.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Forwarded Records/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\PAL Generated(*)\Forwarded Records to Batch Requests Ratio Percentage" ID="{065d536d-89a5-4efd-a56b-302166cfeffe}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Forwarded Records/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsForwardedRecordssec" EXPRESSIONPATH="\SQLServer:Access Methods\Forwarded Records/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Forwarded Records/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\Forwarded Records to Batch Requests Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\Forwarded Records to Batch Requests Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedForwardedRecordsToBatchRequestsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedForwardedRecordsToBatchRequestsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerAccessMethodsForwardedRecordssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerAccessMethodsForwardedRecordssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerAccessMethodsForwardedRecordssecWithComputer = "$($CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerAccessMethodsForwardedRecordssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {               
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerAccessMethodsForwardedRecordssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerAccessMethodsForwardedRecordssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerAccessMethodsForwardedRecordssec))\Forwarded Records to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedForwardedRecordsToBatchRequestsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 forwarded record for every 10 batch requests" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedForwardedRecordsToBatchRequestsRatioPercentage -Operator 'gt' -Threshold 10
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Access Methods\Forwarded Records/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Forwarded Records/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\PAL Generated(*)\Forwarded Records to Batch Requests Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\Forwarded Records to Batch Requests Ratio Percentage" CHARTLABELS="computer">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedForwardedRecordsToBatchRequestsRatioPercentage -MinThreshold 10 -MaxThreshold 29.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:Access Methods Forwarded Records/sec</B>
<BR>
<BR><B>Description:</B> Rows with varchar columns on tables without a clustered index can experience expansion when varchar values are updated with a longer string.  In the case where the row cannot fit in the existing page, the row migrates and access to the row will traverse a pointer.  
Forwarded records occur when a data record in a heap increases in size and the record's current page does not have the space to store the size increase. The record is moved to a new location, becoming a forwarded record, and the forwarding record is left in the original location to point to the real location of the record. The forwarded record points back to the forwarding record in case its location ever needs to change again.
Access Methods Forwarded Records/sec measures the number of records accessed through forwarded record pointers which are due to tables without a clustered index. A forwarded record is basically a pointer. For instance, if you start with a short row, and update the row creating a wider row, the row might not fit on the data page. A pointer is put in its location and the row is forwarded to another page. Forwarding Records are used as a performance optimization so that all the non-clustered indexes on the heap do not have to be altered with the new location of the heap record.
If a table has lots of forwarded records, scanning the table can be very inefficient.
Also, rows with varchar columns can experience expansion when varchar values are updated with a longer string. In the case where the row cannot fit in the existing page, the row migrates and access to the row will traverse a pointer. 
Forwarded Records only occurs on heaps which are tables without clustered indexes. 
<BR><B>Threshold:</B> (Yellow) - This value should not be greater than 10% of the number of Batch Requests/Sec
<BR><B>Next Steps:</B>
<BR>Look at code to determine where the short row is inserted followed by an update. <BR><B>Forwarded records can be avoided by:</B>
<BR><LI>Evaluate clustered indexes for heap tables.
<LI>Using default values so that an update does not result in a longer row that is the root cause of forwarded records.
<LI>Using Char instead of Varchar. Using Char creates a fixed length so that an update does not result in a longer row. 
<LI>In cases where clustered indexes cannot be used, drop non-clustered indexes, build a clustered index to reorganize pages and rows, drop the clustered index, and then recreate non-clustered indexes. 
<LI>Learn to use the sys.dm_db_index_physical_stats dynamic management view (DMV) to find forwarded records. In the sys.dm_db_index_physical_stats DMV there is a column used called the forwarded_record_count which counts the number of records in a heap that have forward pointers to another data location. (This state occurs during an update, when there is not enough room to store the new row in the original location.)
<BR><B>Reference:</B>
<BR><B>SQL Server Storage Engine</B>
http://blogs.msdn.com/sqlserverstorageengine/archive/2006/09/19/761437.aspx 
<BR><B>Forwarding and forwarded records, and the back-pointer size</B>
http://www.sqlskills.com/BLOGS/PAUL/post/Forwarding-and-forwarded-records-and-the-back-pointer-size.aspx 
<BR><B>sys.dm_db_index_physical_stats (Transact-SQL)</B>
<BR>http://msdn.microsoft.com/en-us/library/ms188917.aspx 
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms177426.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods FreeSpace Scans/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\PAL Generated(*)\FreeSpace Scans to Batch Requests Ratio Percentage" ID="{58bdd0bf-21d1-4c5a-8ff7-31f05782ab0c}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\FreeSpace Scans/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsFreeSpaceScanssec" EXPRESSIONPATH="\SQLServer:Access Methods\FreeSpace Scans/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\FreeSpace Scans/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\FreeSpace Scans to Batch Requests Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\FreeSpace Scans to Batch Requests Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedFreeSpaceScansToBatchRequestsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedFreeSpaceScansToBatchRequestsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerAccessMethodsFreeSpaceScanssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerAccessMethodsFreeSpaceScanssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerAccessMethodsFreeSpaceScanssecWithComputer = "$($CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerAccessMethodsFreeSpaceScanssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerAccessMethodsFreeSpaceScanssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerAccessMethodsFreeSpaceScanssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerAccessMethodsFreeSpaceScanssec))\FreeSpace Scans to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedFreeSpaceScansToBatchRequestsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 freespace scan for every 10 batch requests" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedFreeSpaceScansToBatchRequestsRatioPercentage -Operator 'gt' -Threshold 10
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\PAL Generated(*)\FreeSpace Scans to Batch Requests Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\FreeSpace Scans to Batch Requests Ratio Percentage" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedFreeSpaceScansToBatchRequestsRatioPercentage -MinThreshold 10 -MaxThreshold 29.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <CHART CHARTTITLE="\SQLServer:Access Methods\FreeSpace Scans/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\FreeSpace Scans/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="computer" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Access Methods FreeSpace Scans/sec</B>

<BR><B>Description:</B>
<BR>This counter represents inserts into a table with no physical ordering of the rows. A table with no ordering, without a clustered index, is known as a heap table. Inserts into heaps will require SQL Server to perform freespace scans to identify pages with free space to insert rows. A heap table also requires an additional, internal column called an uniquifier to be generated for each row inserted. 
Extra processing is required to define and store a heap table since SQL Server normally uses the clustered index as a storage mechanism for the table data. Freespace scans have an additional I/O expense for inserts and can possibly cause contention on the GAM, SGAM, and PFS pages when there are many connections inserting. 
It is usually recommended that you physically order the table rows by using a clustered index on the table.
FreeSpace Scans/sec represents inserts into a table with no physical ordering of its rows which is called a heap. A heap table requires an additional column called an uniquifier to be generated for each row inserted. It is recommended that you physically order the table rows by using a clustered on the table for most tables.
FreeSpace Scans/sec measures the number of scans per second that were initiated to search for free space within pages already allocated to an allocation unit to insert or modify record fragments. Each scan may find multiple pages. FreeSpace Scans are due to inserts into heaps that require SQL Server to perform freespace scans to identify pages with free space to insert rows. Freespace scans are an additional I/O expense for inserts and can possibly cause contention on the GAM, SGAM, and PFS pages when many spids are inserting. The solution is often to add a clustered index for base tables.
One or more of the following symptoms may accompany poor performance during inserts to a large table on SQL Server: 
<BR>
<LI>Unexplained high CPU usage by SQL Server, sometimes up to 100%.
<LI>SQL Profiler or SHOWPLAN indicates that singleton inserts have wide variations in performance.
<LI>The number of reads is out of proportion to the number or size of the indexes and triggers on the table.
<LI>Sporadic timeouts.
<LI>The FreeSpace Scans/Sec counter from the SQL Server:Access Methods object in Performance Monitor is excessively high given all the factors involved in your specific environment. 
A common cause for these symptoms is that inserts to a heap (a table without a clustered index) are often slower than inserts to a table with a clustered index (a clustered table).
<BR><B>Threshold: </B>
<BR><B>Yellow:</B> A ratio (10%) or more than 1 freespace scan for every 10 Batch Requests/Sec
<BR><B>Next Steps:</B>
Microsoft recommends that you add a clustered index to the table and test the effect of the clustered index on performance.
<B>Reference:</B>
<BR><B>PRB: Poor Performance on a Heap</B>
<BR>http://support.microsoft.com/kb/297861 
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms177426.aspx  

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Full Scans/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\PAL Generated(*)\Full Scans to Index Searches Ratio" ID="{0e57536e-d2c6-4460-9906-d7ba31803964}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Full Scans/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsFullScanssec" EXPRESSIONPATH="\SQLServer:Access Methods\Full Scans/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Full Scans/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Access Methods\Full Scans/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Full Scans/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Access Methods Full Scans/sec</B>
<BR><B>Description:</B> This counter monitors the number of full scans on base tables or indexes. High values indicate that we may be having performance issues due to table / index page scans. If we see high CPU and / or drops in Page Life Expectancy (PLE) then we need to investigate this counter; however, if full scans are on small tables we can safely ignore this counter as this counter tracks all full table scans, not just those on large tables. A few of the main causes of high Full Scans/sec are missing indexes, too many rows requested, queries with missing indexes, or too many rows requested will have a large number of logical reads and an increased CPU time.
<BR>
This analysis throws a Warning alert if the ratio of Index Searches/sec to Full Scans/sec is less than 1000 to 1 and if there are more than 1000 Index Searches/sec.
<BR>
<B>Note:</B> This counter monitors the number of full scans on tables or indexes. This counter can be ignored unless there is also poor disk performance, and / or, high CPU use along with high scan rates. High scan rates may be caused by missing indexes, very small tables, or requests for too many records. 
<BR><B>Next Steps:</B>
The main causes of high Full Scans/sec are:
<LI>Missing indexes
<LI>Too many rows requested queries with missing indexes or too many rows requested will have a large number of logical reads (disk impact) and an increased CPU time. As mentioned, if there is a high level of Full Scans to Index Searches, then it is important to also check the following:
See PERFMON SQLServer:Buffer Manager performance counters for memory pressure:
<LI>Page Life Expectancy
<LI>Checkpoint pages/sec
<LI>Lazy writes/sec
A high number of scans can cause buffer pool pressure (as indicated with low PLE and a higher Lazy Writes / sec count).
Memory pressure will quickly manifest into disk pressure, so also check:
See PERFMON Physical Disk performance counters: 
<LI>Disk sec/read
<LI>Disk sec/write
<BR><B>Note:</B> Identify disk bottlenecks by using Performance Counters, Profiler, sys.dm_io_virtual_file_stats and SHOWPLAN output.
Also refer to the sys.dm_io_virtual_file_stats dynamic management view (DMV) to track io_stalls to help identify IO bottlenecks. 
To back up and support this information, compare the counters to sys.dm_os_wait_stats output. If you see high values in perfmon, you may also see high waits for the following:
<LI>ASYNC_IO_COMPLETION
<LI>IO_COMPLETION
<LI>PAGEIOLATCH_* (Data page I/O completion waits appear as PAGEIOLATCH_* waits)
Reactively, SQL Profiler can be used to identify which SQL statements are causing scans. Use the scans event class and events scan:started and scan:completed. Include the object ID data column. Save the profiler trace to a file and then convert it to trace table. You can then search for the scans event. 
The scan:completed event provides the associated IO so that you can also search for high reads, writes, and duration.
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
http://msdn.microsoft.com/en-us/library/ms177426.aspx 
<BR><B>SQL Server 2005 Waits and Queues</B>
http://download.microsoft.com/download/4/7/a/47a548b9-249e-484c-abd7-29f31282b04d/Performance_Tuning_Waits_Queues.doc 
<BR><B>Wait Types and Correlation to Other Performance Info</B>
http://www.sqlmag.com/Files/09/40925/Webtable_01.doc]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Page Splits/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\PAL Generated(*)\Page Splits to Batch Requests Ratio Percentage" ID="{8b560238-c23b-4dcb-8c48-87ebcd29067b}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Page Splits/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsPageSplitssec" EXPRESSIONPATH="\SQLServer:Access Methods\Page Splits/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Page Splits/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\Page Splits to Batch Requests Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\Page Splits to Batch Requests Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedPageSplitsToBatchRequestsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedPageSplitsToBatchRequestsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerAccessMethodsPageSplitssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerAccessMethodsPageSplitssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerAccessMethodsPageSplitssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerAccessMethodsPageSplitssecWithComputer = "$($CollectionOfSQLServerAccessMethodsPageSplitssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerAccessMethodsPageSplitssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerAccessMethodsPageSplitssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerAccessMethodsPageSplitssec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerAccessMethodsPageSplitssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerAccessMethodsPageSplitssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerAccessMethodsPageSplitssec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerAccessMethodsPageSplitssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerAccessMethodsPageSplitssec))\Page Splits to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedPageSplitsToBatchRequestsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 page split for every 20 batch requests" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedPageSplitsToBatchRequestsRatioPercentage -Operator 'gt' -Threshold 20
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Access Methods\Page Splits/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Page Splits/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\PAL Generated(*)\Page Splits to Batch Requests Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\Page Splits to Batch Requests Ratio Percentage" CHARTLABELS="computer">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedPageSplitsToBatchRequestsRatioPercentage -MinThreshold 20 -MaxThreshold 29.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:Access Methods Page Splits/sec</B>
<BR>
<B>Description:</B> The number of page splits per second that occurs as the result of overflowing index pages and new page allocations. When a record is inserted into an index, it must be inserted in order. If the data page is full, the page splits in order to maintain the appropriate order. A high value for this counter may warrant the consideration of a lower fill factor and pad_index to leave more empty space per page.
This value should be as low as possible. Heavily fragmented indexes may be the result of high page splits/sec.
<BR><B>Note:</B> A high value for this counter is not bad in situations where many new pages are being created, since it includes all new page allocations as well as splits when a data page spilts.
<BR><B>Threshold:</B>
<BR>Yellow: A ratio of more than 1 page split for every 20 batch requests
<BR><B>Next Steps:</B>
If the number of page splits is high, consider increasing the fillfactor of your indexes. An increased fillfactor helps to reduce page splits by increasing the amount of free space on each page. 
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms177426(v=SQL.105).aspx 
<BR>
<b>To track page splits more accurately see the following SQLSkills blog article from Jonathan Kehayias:</B>
http://www.sqlskills.com/blogs/jonathan/post/Tracking-Problematic-Pages-Splits-in-SQL-Server-2012-Extended-Events-e28093-No-Really-This-Time!.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Scan Point Revalidations/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\SQLServer:Access Methods\Scan Point Revalidations/sec" ID="{11783979-b247-48b8-994c-f50d171b4106}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Scan Point Revalidations/sec" COLLECTIONVARNAME="SQLServerAccessMethodsScanPointRevalidationssec" EXPRESSIONPATH="\SQLServer:Access Methods\Scan Point Revalidations/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Scan Point Revalidations/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Access Methods\Scan Point Revalidations/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Scan Point Revalidations/sec" CHARTLABELS="instance">
    </CHART>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Access Methods\Scan Point Revalidations/sec</B>
<BR>
<B>Description:</B> Scan Point Revalidations occurs during range scans. When a range scan occurs there is an optimization process that occurs where the pages are marked as satisfied with the WHERE predicate that does the range scan. 
Instead of scanning through each and every row in the page, it does not keep an exclusive lock on those pages; instead it just keeps a mark on it and continues with rest of the scan. If one or more rows in the page are modified by update or a delete operation, the update or delete process will notify the scan to recheck the page to see if the page is still valid for the range scan. This recheck is called a Scan Point Revalidation.
Scan Point Revalidations shows the contention between range scans and modifications to the same pages. This counter also pinpoints hotspots within the cluster table competing between reads and writes.
Scan Point Revalidations are the number of times per second that the scan point had to be revalidated before the scan could be continued. If a page latch has to be released due to contention, the scan point must be revalidated when the scan resumes. 
<BR>
<B>Note:</B> This is an informative counter. It is not a critical counter that should be used for baselines or alerting.
<BR><B>Next Steps:</B> You can correlate the Scan Count Revalidations/sec with the Range Scans/sec counter and Page Latch related counters. The higher the number of range scans on the same pages, the higher the number of scan point revalidations.
High number of Scan Point Revalidations/sec potentially indicate hot spots in the data, probably due to a poor choice of clustered index putting the most active rows on the same page.
Consider reducing the number of range scans, isolating reporting and application use, and most importantly ensuring that the clustered index choice is the right one. Clustered indexes should be on columns that are sorted on, grouped on, used in joins, used in between queries, and in other operations where the order of the returned data is critical.
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms177426.aspx 
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Workfiles Created/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\SQLServer:Access Methods\Workfiles Created/sec" ID="{9967dc1f-ee36-4052-ba68-4a8ad8af9a97}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Workfiles Created/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec" EXPRESSIONPATH="\SQLServer:Access Methods\Workfiles Created/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Workfiles Created/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\Workfiles Created to Batch Requests Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\Workfiles Created to Batch Requests Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedWorkfilesCreatedToBatchRequestsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedWorkfilesCreatedToBatchRequestsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerAccessMethodsWorkfilesCreatedsec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].CounterObject
            $sSqlInstanceNameForSQLServerAccessMethodsWorkfilesCreatedsecWithComputer = "$($CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerAccessMethodsWorkfilesCreatedsec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerAccessMethodsWorkfilesCreatedsecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerAccessMethodsWorkfilesCreatedsec))\Workfiles Created to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedWorkfilesCreatedToBatchRequestsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <CHART CHARTTITLE="\SQLServer:Access Methods\Workfiles Created/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Access Methods\Workfiles Created/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec -MinThreshold 20 -MaxThreshold 24.999 -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\PAL Generated(*)\Workfiles Created to Batch Requests Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\Workfiles Created to Batch Requests Ratio Percentage" CHARTLABELS="computer">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedWorkfilesCreatedToBatchRequestsRatioPercentage -MinThreshold 20 -MaxThreshold 39.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="A ratio of more than 1 workfile created for every 20 batch requests" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedWorkfilesCreatedToBatchRequestsRatioPercentage -Operator 'gt' -Threshold 20
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 20 Workfiles created per second" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerAccessMethodsWorkfilesCreatedsec -Operator 'gt' -Threshold 20
         ]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Access Methods\Workfiles Created/sec</B>
<BR><BR>
<B>Description: </B>
Number of Workfiles created in the last second. Workfiles in TempDB are used in processing hash operations when the amount of data being processed is too big to fit into the available memory. The Work files are similar to work tables but are created strictly by hashing operations. Workfiles are used to store temporary results for hash joins and hash aggregates.<BR>
Hash joins can require large amounts of memory for execution. As part of executing a hash join, the memory required for the hash can become too large and require a spill to disk. The disk storage to backup the hash operation is called a workfile. Workfiles are collections of extents and pages that are managed strictly by the workfile code.
<BR>
<B>Threshold: </B>
<BR>Yellow: Greater than 20 Workfiles created per second
<BR>
<B>Next Steps:</B> 
Make queries more efficient by adding/changing indexes. Run expensive queries through the Database Tuning Advisor (DTA), look for expensive queries and consider rewriting them, and add as last resort consider adding additional memory.
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://technet.microsoft.com/en-us/library/ms177426.aspx
<BR>
<B>Working with tempdb in SQL Server 2005 </B>
<BR>http://msdn.microsoft.com/en-us/library/cc966545.aspx
<BR>
<B>Troubleshooting Performance Problems in SQL Server 2008</B>
<BR>http://download.microsoft.com/download/D/B/D/DBDE7972-1EB9-470A-BA18-58849DB3EB3B/TShootPerfProbs2008.docx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Worktables Created/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\SQLServer:Access Methods\Worktables Created/sec" ID="{289fe43d-3e27-4bde-bc1c-486b3cf7e8d1}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Worktables Created/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsWorktablesCreatedsec" EXPRESSIONPATH="\SQLServer:Access Methods\Worktables Created/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Worktables Created/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 20 Worktables created per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerAccessMethodsWorktablesCreatedsec -Operator 'gt' -Threshold 20
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Access Methods\Worktables Created/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Access Methods\Worktables Created/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerAccessMethodsWorktablesCreatedsec -MinThreshold 20 -MaxThreshold 24.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Access Methods\Worktables Created/sec</B>
<BR>
<BR><B>Description:</B> Number of worktables created in the last second. The number of work tables created per second. Work tables are temporary objects and are used to store results for query spool, LOB variables, and cursors.

<BR><B>Threshold:</B>
<BR>Yellow: Greater than 20 Worktables created per second. This will need to be baselined for accuracy.
<BR><B>Next Steps:</B><BR> Look for expensive statements with high CPU, duration, and statements that run in parallel and tune them by adding indexes, reducing the volume of data being returned, and adding indexes where appropriate.
Ensure that TempDB is not a bottleneck and is following best practices.
If you determine that the throughput of your application has degraded because of contention in allocation structures, you can use the following techniques to minimize it.
Evaluate your application and the query plans to see if you can minimize the creation of work tables and temporary tables. Monitor the perfmon counters as described in Monitoring contention caused by DML operations. Then, use SQL Profiler to correlate the values of these counters with the currently running queries. This helps you identify the queries that are causing the contention in allocation structures. 
Divide TempDB into multiple data files of equal size. These multiple files don't necessarily need to be on different disks/spindles unless you are also encountering I/O bottlenecks as well. The general recommendation is to have one file per CPU because only one thread is active per CPU at one time. SQL Server allocates pages for TempDB objects in a round-robin fashion (also referred to as proportional fill) so that the latches on PFS and SGAM pages are distributed among multiple files. This is supported both in SQL Server 2000 and SQL Server 2005. There are improvements to the proportional fill algorithm in SQL Server 2005.
Use TF-1118. Under this trace flag SQL Server allocates full extents to each TempDB object, thereby eliminating the contention on SGAM page. This is done at the expense of some waste of disk space in TempDB. This trace flag has been available since SQL Server 2000. With improvements in TempDB object caching in SQL Server 2005, there should be significantly less contention in allocation structures. If you see contention in SGAM pages, you may want to use this trace flag. Cached TempDB objects may not always be available. For example, cached TempDB objects are destroyed when the query plan with which they are associated is recompiled or removed from the procedure cache.

<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://technet.microsoft.com/en-us/library/ms177426.aspx 
<BR><B>Working with TempDB in SQL Server 2005</B>
<BR>http://msdn.microsoft.com/en-us/library/cc966545.aspx 
<BR><B>Troubleshooting Performance Problems in SQL Server 2008</B>
<BR>http://download.microsoft.com/download/D/B/D/DBDE7972-1EB9-470A-BA18-58849DB3EB3B/TShootPerfProbs2008.docx ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Buffer cache hit ratio" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Buffer cache hit ratio" ID="{973c124a-ac03-4b31-abe4-d7bdc2a9f8bc}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Buffer cache hit ratio" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerBuffercachehitratio" EXPRESSIONPATH="\SQLServer:Buffer Manager\Buffer cache hit ratio" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Buffer cache hit ratio" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Checkpoint pages/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerCheckpointpagessec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Checkpoint pages/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Checkpoint pages/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Less than 97 percent buffer cache hit ratio" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerBuffercachehitratio -Operator 'lt' -Threshold 97
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Checkpoint pages/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Checkpoint pages/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Buffer cache hit ratio" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Buffer Manager\Buffer cache hit ratio" CHARTLABELS="computer" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerBuffercachehitratio -MinThreshold 0.001 -MaxThreshold 97 -UseMaxValue $True -IsOperatorGreaterThan $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Less than 90 percent buffer cache hit ratio" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerBuffercachehitratio -Operator 'lt' -Threshold 90
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Buffer Manager\Buffer cache hit ratio</B>

<BR><BR><B>Description:</B> The Buffer Cache Hit Ratio measures the percentage of pages that were found in the buffer pool without having to incur a read from disk. This counter indicates how often SQL Server goes to the buffer, not the hard disk, to get data. The higher this ratio, the better. A high ratio, close to 100% indicates that SQL Server did not have to go to the hard disk often to fetch data, and performance overall is boosted. If the Buffer Cache Hit Ratio was 100% that would suggest that all of the pages are being accessed from cache and does not require trips to disk, because of the optimistic read ahead mechanism, this is not exactly the case.
When a user session wants to read data from the database, it will read directly from the SQL Server buffer cache (a logical read), or, if the buffer cache does not have the data that is requested, the data will be read into the buffer cache from disk (a physical read) and then from the buffer cache. If the requested data is in the buffer cache, then it is called a 'buffer hit'. If the data is not in the buffer cache it is called a 'buffer miss'. The ratio of buffer hits to total buffer requests is called the buffer cache hit ratio as can be seen from the following:
<BR><BR><B>Cache Hit Ratio = (Logical Reads - Physical Reads)/Logical Reads</B><BR>
<BR>A read from memory takes approximately 100 nanoseconds, while a read from disk takes about 8 milliseconds or more.
1 millisecond = 1,000,000 nanoseconds
The important point about SQL Server read operations is that when selecting data from the database, the user will wait on the complete read operation including all of the physical reads. The time is takes to select from the database depends on how much data will be read and how long it takes for those reads to occur. Even with cache reads, the time it takes to read a large amount of data can be significant. With physical reads, the time will be even longer.
There are a few considerations to be aware of regarding the Buffer Cache Hit Ratio counter. First, unlike many of the other counters available for monitoring SQL Server, this counter averages the Buffer Cache Hit Ratio from the time the instance of SQL Server was started. In other words, this counter is not a real-time measurement, but an average. Secondly, the buffer cache hit ratio may be skewed by the read ahead mechanism. Read Ahead Reads are pages that were read into cache while the query was processed. Read aheads are an optimistic form of physical reads. Because of the read ahead mechanism, you should not infer from a high buffer cache hit ratio that SQL Server is not suffering from memory pressure or at least could not benefit from additional memory.
 
<BR><B>Threshold: </B>
<BR><B>Yellow: </B>Less than 97 percent buffer cache hit ratio
<BR><B>Red: </B>Less than 90 percent buffer cache hit ratio
<BR><B>Next Steps:</B>
<BR>Run expensive queries through the Database Tuning Advisor (DTA), add additional memory, and look for queries with a high number of logical reads and consider tuning and potentially rewriting them.
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms177426.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Free pages" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Free pages" ID="{4637f97e-3033-4165-82e8-8560662e7caf}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Free pages" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerFreepages" EXPRESSIONPATH="\SQLServer:Buffer Manager\Free pages" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Free pages" DATATYPE="integer" />
    <THRESHOLD NAME="Less than 640 Free Pages" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerFreepages -Operator 'lt' -Threshold 640
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Free pages" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Buffer Manager\Free pages" CHARTLABELS="instance" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerFreepages -MinThreshold 0.001 -MaxThreshold 640 -UseMaxValue $True -IsOperatorGreaterThan $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Buffer Manager\Free pages</B>
<BR>
<B>Description:</B> Total number of pages on all free lists. The more free pages that are available then the less often the lazy writer will have to fire keeping pages in the buffer pool longer.
<BR>

A value less than 640 (or 5 MB) may indicate physical memory pressure.

<BR><B>Threshold: </B>
<BR><B>Yellow:</B> Less than 640 Free Pages<BR>
<BR><B>Next Steps:</B>
Compare the Buffer Manager\Free pages counter to the following:<BR>
<LI>Buffer Manager\Lazy Writes /sec
<LI>Buffer Manager\Page Life Expectancy
<BR><BR>The higher the Buffer Manager\Free pages then the higher the Buffer Manager\Page Life Expectancy should be. If Buffer Manager\Free pages is low then the Buffer Manager\Lazy Writes /sec will be higher as the Lazy Writer will become active attempting to free the buffer cache as SQL Server will be under memory pressure.
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>

<BR>http://msdn.microsoft.com/en-us/library/ms177426.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Lazy writes/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Lazy writes/sec" ID="{9c5005f4-b76d-49ef-854b-4384df2d4cbe}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Lazy writes/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerLazywritessec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Lazy writes/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Lazy writes/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Checkpoint pages/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerCheckpointpagessec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Checkpoint pages/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Checkpoint pages/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 20 Lazy Writes per second" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerLazywritessec -Operator 'gt' -Threshold 20
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Checkpoint pages/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Checkpoint pages/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Lazy writes/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Buffer Manager\Lazy writes/sec" CHARTLABELS="computer">
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerLazywritessec -MinThreshold 20 -MaxThreshold 39.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Buffer Manager\Lazy writes/sec</B>
<BR><BR><B>Description:</B>
The Lazy Writes/sec counter records the number of buffers written each second by the buffer manager's lazy write process. This counter tracks how many times a second that the Lazy Writer process is moving dirty pages from the buffer to disk in order to free up buffer space. This process is where the dirty, aged buffers are removed from the buffer by a system process that frees the memory up for other uses. A dirty, aged buffer is one that has changes and needs to be written to the disk. High value on this counter possibly indicates I/O issues or even SQL Server memory problems. The Lazy writes / sec values should consistently be less than 20 for the average system.
Generally speaking, this should not be a high value, say more than 20 per second or so.  Ideally, it should be close to zero. If it is zero, this indicates that your SQL Server's buffer cache is plenty big and SQL Server doesn't have to free up dirty pages, instead waiting for this to occur during regular checkpoints. If this value is high, then a need for more memory is indicated.
<BR>

<B>Note:</B> NUMA will increase the number of lazy writer threads per NUMA node and influence the behavior of the lazy writer by increasing its execution at this view. If the server is a NUMA environment other signs of memory pressure should be used and you should analyze the Buffer Node counters for Page Life Expectancy per node. There is not a lazy writer counter in Buffer Nodes.
<BR>
<B>Threshold: </B>
<BR><B>Red:</B> Greater than 20 Lazy Writes per second
<BR>



<B>Next Steps:</B>
Look for an increase in SQL Server: Buffer Manager: Checkpoint Pages/sec and SQL Server:Buffer Manager: Lazy Writes/sec performance object counters because SQL Server 2005 starts to flush pages out of the buffer pool cache under memory pressure.
<BR>

<B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms177426.aspx

<BR>
<B>Configure SQL Server to Use Soft-NUMA</B><BR>
http://msdn.microsoft.com/en-us/library/ms345357.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Page life expectancy" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Page life expectancy" ID="{0370e574-f56b-403e-b91a-59202f0e0509}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Page life expectancy" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerPagelifeexpectancy" EXPRESSIONPATH="\SQLServer:Buffer Manager\Page life expectancy" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Page life expectancy" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Page life expectancy" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Buffer Manager\Page life expectancy" CHARTLABELS="instance" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[$SeventyPercentOfPLEHealth = $([Int]$PLEHealth) * 0.70
StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagelifeexpectancy -MinThreshold $SeventyPercentOfPLEHealth -MaxThreshold 300 -IsOperatorGreaterThan $True -UseMaxValue $False]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[$SeventyPercentOfPLEHealth = $([Int]$PLEHealth) * 0.70
StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagelifeexpectancy -MinThreshold 0.001 -MaxThreshold $SeventyPercentOfPLEHealth -UseMaxValue $True -IsOperatorGreaterThan $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Less than 70% (700 seconds by default) of the Page Life Expectancy Baseline" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[$SeventyPercentOfPLEHealth = $([Int]$PLEHealth) * 0.70
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagelifeexpectancy -Operator 'lt' -Threshold $SeventyPercentOfPLEHealth]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 30% (300 seconds by default) of the Page Life Expectancy Baseline" CONDITION="Critical" COLOR="Red" PRIORITY="99">
      <CODE><![CDATA[$ThirtyPercentOfPLEHealth = $([Int]$PLEHealth) * 0.30
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagelifeexpectancy -Operator 'lt' -Threshold $ThirtyPercentOfPLEHealth
        ]]></CODE>
    </THRESHOLD>
    <!--<THRESHOLD NAME="Page life expectancy is less then 5 minutes" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE>
        <![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagelifeexpectancy -Operator 'lt' -Threshold 300
         ]]>
      </CODE>
    </THRESHOLD>-->
    <THRESHOLD NAME="Decreasing Trend of 30% PLEHealth (300 seconds default) per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[$ThirtyPercentOfPLEHealth = -$([Int]$PLEHealth) * 0.30
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagelifeexpectancy -Operator 'lt' -Threshold $ThirtyPercentOfPLEHealth -IsTrendOnly $True]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer_Buffer Manager Page Life Expectancy</B>
<BR><BR>
<B>Description:</B>
Number of seconds a page will stay in the buffer pool without references. This performance monitor counter tells you, on average, how long data pages are staying in the buffer. Any large drops of 30% or more should be investigated. Below 600 should be monitored and very low values near zero are considered a critical state. For monitoring, we are alerting at a warning level at 600 and a critical state of lower than 300 seconds, though getting a baseline is the best approach.
<BR>
When page life expectancy gets too low, this is an indication that SQL Server is doing too many logical reads putting pressure on the buffer pool. It is recommended to correlate page life expectancy with lazy writer activity. When page life expectancy becomes low, then SQL Server will respond by sweeping through the buffer pool using the lazy writer, increasing lazy writer activity. Low page life expectancy may cause more physical reads increasing pressure on disk and slowing down SQL Server responsiveness.
<BR>
The Page life expectancy counter is considered one of the most critical counters for SQL Server. If Page life expectancy becomes low SQL Server will attempt physical reads from disk into the buffer pool to honor requests. Requests from physical disk will take considerably longer causing higher disk costs. 
<BR>
<B>Note:</B> NUMA systems will have a CPU and memory grouping per node. If the server is a NUMA environment you should analyze the Buffer Node counters for Page Life Expectancy per node. You can tell a server is a NUMA system by checking the SQL Server error log or by querying sys.dm_os_memory_nodes. A non-NUMA system will have 2 nodes listed, A NUMA system will have additional nodes for each of the hardware NUMA nodes in the system.
<BR><B>Threshold:</B>
<BR><B>Yellow:</B> Page life expectancy is less than 10 minutes (600 seconds)
<BR><B>Red:</B> Page life expectancy is less than 5 minutes (300 seconds)

<BR><B>Next Steps:</B><BR>
If Buffer Manager\Page life expectancy is low then the Buffer Manager\Lazy Writes /sec will be higher as the Lazy Writer will become active attempting to free the buffer cache as SQL Server will be under memory pressure.
Due to the disk impact of the physical reads incurred, the \Physical Disk \Avg. Disk sec/Read counter may also become a bottleneck as SQL Server is reading from disk instead of the buffer pull to honor requests.
Look for an increase in SQL Server: Buffer Manager: Checkpoint Pages/sec and SQL Server:Buffer Manager: Lazy Writes/sec performance object counters because SQL Server 2005 / 2008 starts to flush pages out of the buffer pool cache under memory pressure.
Run expensive queries through the Database Tuning Advisor (DTA), look for queries with a high number of logical reads and consider tuning and potentially rewriting them, and potentially add additional memory if non-hardware options to not address the issue.

<BR><B>Reference:</B>

<BR><B>SQL Server, Access Methods Object</B>

http://msdn.microsoft.com/en-us/library/ms177426.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Page lookups/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Page lookups/sec" ID="{8e78050f-b5b0-460d-83cc-d58cb25902d7}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Page lookups/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerPagelookupssec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Page lookups/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Page lookups/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\Page lookups to Batch Requests Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\Page lookups to Batch Requests Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedPageLookupsToBatchRequestsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedPageLookupsToBatchRequestsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerBufferManagerPagelookupssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerBufferManagerPagelookupssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerBufferManagerPagelookupssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerBufferManagerPagelookupssecWithComputer = "$($CollectionOfSQLServerBufferManagerPagelookupssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerBufferManagerPagelookupssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerBufferManagerPagelookupssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerBufferManagerPagelookupssec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerBufferManagerPagelookupssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerBufferManagerPagelookupssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerBufferManagerPagelookupssec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerBufferManagerPagelookupssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerBufferManagerPagelookupssec))\Page lookups to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedPageLookupsToBatchRequestsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 page lookup for every 100 batch requests" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedPageLookupsToBatchRequestsRatioPercentage -Operator 'gt' -Threshold 100
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Page lookups/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Page lookups/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\PAL Generated(*)\Page lookups to Batch Requests Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\Page lookups to Batch Requests Ratio Percentage" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedPageLookupsToBatchRequestsRatioPercentage -MinThreshold 100 -MaxThreshold 119.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:Buffer Manager Page Lookups/sec</B>
<BR><B>Description:</B><BR>
Number of requests to find a page in the buffer pool. When the ratio of page lookups to batch requests is greater than 100, this is an indication that while query plans are looking up data in the buffer pool, these plans are inefficient or there was a large number of ad-hoc queries.

<BR>
<B>Threshold:</B> 
Ratio of Page Lookups/sec to Batch Requests/sec < 100 to 1.
<BR><B>Warning:</B> Page life expectancy is less than 5 minutes (300 seconds)
<BR><B>Next Steps:</B>
Page Lookups/sec is the number of requests to find a page in the buffer pool made per second. If this number is high as compared to the number of batch requests, this indicates a degree of inefficiency and a potential opportunity for tuning.
Identify queries with the highest amount of logical I/O's and tune them. 
<BR><B>Note:</B> You can track the Page Lookups/sec and other counters through the sys.dm_os_performance_counters DMV which contains all the SQL Server instance object-related counters that you can find in perfmon.
<BR><B>Reference:</B>
<BR><B>SQL Server, Buffer Manager Object</B>
http://msdn.microsoft.com/en-us/library/ms189628.aspx 
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Page reads/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Page reads/sec" ID="{c27443ca-be58-415d-9830-8b2ace39a234}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Page reads/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerPagereadssec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Page reads/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Page reads/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 90 page reads per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagereadssec -Operator 'gt' -Threshold 90
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Page reads/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Buffer Manager\Page reads/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagereadssec -MinThreshold 90 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer_Buffer Manager Page Reads_sec</B>
<BR><B>Description:</B> Number of physical database page reads issued per second. Number of physical database page reads issued. 80 to 90 per second is normal, anything that is above indicates indexing or memory constraint.
<BR><B>Threshold: </B>
<BR><B>Yellow:</B> Page Reads/sec > 90
<BR><B>Next Steps:</B>
Attempt to tune the application so that fewer I/O operations are required. For example, perhaps I/O would be reduced if there were appropriate indexes or if the database design were denormalized.
If the applications cannot be tuned, you will need to acquire disk devices with more capacity.
Compare to the Memory: Pages/sec counter to see if there is paging while the SQL Server:Buffer Manager\Page reads/sec is high.
Note: Before adjusting the fill factor, at a database level compare the SQL Server:Buffer Manager\Page reads/sec counter to the SQL Server:Buffer Manager\Page writes/sec counter, and use the fill factor option only if writes are a substantial fraction of reads (greater than 30 percent).
<BR><B>Reference:</B>
<BR><B>SQL Server, Buffer Manager Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms189628.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Page writes/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Page writes/sec" ID="{89c3972b-4fd6-432f-892b-313274439b0b}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Page writes/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerPagewritessec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Page writes/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Page writes/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 90 page writes per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagewritessec -Operator 'gt' -Threshold 90
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Page writes/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Buffer Manager\Page writes/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagewritessec -MinThreshold 90 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer_Buffer Manager Page Writes_sec</B>
<BR><B>Description:</B> Number of physical database page writes issued per second.  80 to 90 per second is normal. Anything above 90, it is recommended to check the lazy writer/sec and Checkpoint pages/sec counter, if these counters are also relatively high then, this indicates a memory constraint.
<BR>
<B>Threshold:</B>
<BR><B>Yellow:</B> Page Writes/sec > 90
<BR><B>Next Steps:</B>
Attempt to tune the application so that fewer I/O operations are required. For example, perhaps I/O would be reduced if there were appropriate indexes or if the database design were denormalized.
If the applications cannot be tuned, you will need to acquire disk devices with more capacity.
Compare to the Memory: Pages/sec counter to see if there is paging while the SQL Server:Buffer Manager\Page reads/sec is high.
Note: Before adjusting the fill factor, at a database level compare the SQL Server:Buffer Manager\Page reads/sec counter to the SQL Server:Buffer Manager\Page writes/sec counter, and use the fill factor option only if writes are a substantial fraction of reads (greater than 30 percent).
<BR><B>Reference:</B>
<BR><B>SQL Server, Buffer Manager Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms189628.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:General Statistics Logins/sec" ENABLED="True" CATEGORY="SQLServer:General Statistics" PRIMARYDATASOURCE="\SQLServer:General Statistics\Logins/sec" ID="{ccd92dc1-a7b4-4a15-a9cd-11fa77d5b6f9}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:General Statistics\Logins/sec" COLLECTIONVARNAME="CollectionOfSQLServerGeneralStatisticsLoginssec" EXPRESSIONPATH="\SQLServer:General Statistics\Logins/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:General Statistics\Logins/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 2 logins per second - this may indicate that applications are not correctly using connection pooling" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerGeneralStatisticsLoginssec -Operator 'gt' -Threshold 2
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:General Statistics\Logins/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:General Statistics\Logins/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerGeneralStatisticsLoginssec -MinThreshold 2 -MaxThreshold 3.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Total number of logins started per second. Greater than 2 per second may indicate that applications are not correctly using connection pooling.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:General Statistics Logouts/sec" ENABLED="True" CATEGORY="SQLServer:General Statistics" PRIMARYDATASOURCE="\SQLServer:General Statistics\Logouts/sec" ID="{214aa35c-d80b-4e7a-a922-a9a948e89cbb}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:General Statistics\Logouts/sec" COLLECTIONVARNAME="CollectionOfSQLServerGeneralStatisticsLogoutssec" EXPRESSIONPATH="\SQLServer:General Statistics\Logouts/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:General Statistics\Logouts/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 2 logouts per second - this may indicate that applications are not correctly using connection pooling" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerGeneralStatisticsLogoutssec -Operator 'gt' -Threshold 2
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:General Statistics\Logouts/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:General Statistics\Logouts/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerGeneralStatisticsLogoutssec -MinThreshold 2 -MaxThreshold 3.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:General Statistics Logouts/sec</B>
<BR>
Total number of logouts started per second. Greater than 2 per second indicates that the application is not correctly using connection pooling.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:General Statistics User Connections" ENABLED="True" CATEGORY="SQLServer:General Statistics" PRIMARYDATASOURCE="\SQLServer:General Statistics\User Connections" ID="{606ff65d-cc57-418b-b3ee-53658b1debfa}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:General Statistics\User Connections" COLLECTIONVARNAME="CollectionOfSQLServerGeneralStatisticsUserConnections" EXPRESSIONPATH="\SQLServer:General Statistics\User Connections" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:General Statistics\User Connections" DATATYPE="integer" />
    <THRESHOLD NAME="An increasing trend of greater than 10 user connections per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerGeneralStatisticsUserConnections -Operator 'gt' -Threshold 10 -IsTrendOnly $True
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:General Statistics\User Connections" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:General Statistics\User Connections" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:General Statistics User Connections</B>
<BR>
Number of users connected to the system. The number of users currently connected to the SQL Server. This should correlate with the Batch Requests per second counter.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Latches Latch Waits/sec" ENABLED="False" CATEGORY="SQLServer:Latches" PRIMARYDATASOURCE="\SQLServer:Latches\Latch Waits/sec" ID="{fd5914a7-bb6f-4a96-9133-afc58accf9cf}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Latches\Latch Waits/sec" COLLECTIONVARNAME="CollectionOfSQLServerLatchesLatchWaitssec" EXPRESSIONPATH="\SQLServer:Latches\Latch Waits/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Latches\Latch Waits/sec" DATATYPE="round3" />
    <CHART CHARTTITLE="\SQLServer:Latches\Latch Waits/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Latches\Latch Waits/sec" CHARTLABELS="instance" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Latches\Total Latch Wait Time (ms)" EXPRESSIONPATH="\SQLServer:Latches\Total Latch Wait Time (ms)" COLLECTIONVARNAME="CollectionOfSQLServerLatchesTotalLatchWaitTimeTotalLatchWaitTimemsms" DATATYPE="integer" />
    <THRESHOLD NAME="(Total Latch Wait Time) / (Latch Waits/&#xD;&#xA;Sec) &lt; 10" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerLatchesLatchWaitssec -Operator 'lt' -Threshold 10

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Latches Latch Waits/sec</B>
<BR>
Number of latch requests that could not be granted immediately and had to wait before being granted. These are the amount of latches that had to wait.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Memory Manager Memory Grants Pending" ENABLED="True" CATEGORY="SQLServer:Memory Manager" PRIMARYDATASOURCE="\SQLServer:Memory Manager\Memory Grants Pending" ID="{fa457be5-ebb9-46a6-81d5-706fba8093c0}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Memory Manager\Memory Grants Pending" COLLECTIONVARNAME="CollectionOfSQLServerMemoryManagerMemoryGrantsPending" EXPRESSIONPATH="\SQLServer:Memory Manager\Memory Grants Pending" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Memory Manager\Memory Grants Pending" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 0 memory grants pending" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerMemoryManagerMemoryGrantsPending -Operator 'gt' -Threshold 0
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Memory Manager\Memory Grants Pending" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:Memory Manager\Memory Grants Pending" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerMemoryManagerMemoryGrantsPending -MinThreshold 1 -MaxThreshold 2.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:Memory Manager Memory Grants Pending</B>
<BR>
Current number of processes waiting for a workspace memory grant. Memory Grants Pending records the number of connections that are waiting for memory before they can begin processing a memory intensive query such as a sort or hash operation.  Connections that wait in this state for a long enough time will eventually receive an 8645 error (A time out occurred while waiting for memory resources to execute the query. Rerun the query).  A spid waiting in this state will have a waittype of 0x0040 (RESOURCE_SEMAPHORE) in sysprocesses.  If this counter remains above zero for any significant amount of time then you will need to track down what queries are doing sorts/hashes and run them through Database Tuning Advisor (DTA) to see if they can get a more efficient plan.

<BR>
<B>Threshold:</B>
<BR><B>Red: </B>Numbers higher than 0 indicate a lack of memory.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Memory Manager Target Server Memory(KB)" ENABLED="True" CATEGORY="SQLServer:Memory Manager" PRIMARYDATASOURCE="\SQLServer:Memory Manager\Target Server Memory (KB)" ID="{38744400-aa4e-4466-89e1-e7e51d3ff37b}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Memory Manager\Target Server Memory(KB)" COLLECTIONVARNAME="CollectionOfSQLServerMemoryManagerTargetServerMemoryKB" EXPRESSIONPATH="\SQLServer:Memory Manager\Target Server Memory(KB)" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Memory Manager\Target Server Memory(KB)" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Memory Manager\Total Server Memory (KB)" COLLECTIONVARNAME="CollectionOfSQLServerMemoryManagerTotalServerMemoryKB" EXPRESSIONPATH="\SQLServer:Memory Manager\Total Server Memory (KB)" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Memory Manager\Total Server Memory (KB)" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\Difference of Target and Total Server Memory In Megabytes" EXPRESSIONPATH="\PAL Generated(*)\Difference of Target and Total Server Memory In Megabytes" COLLECTIONVARNAME="CollectionOfPalGeneratedDifferenceOfTargetAndTotalServerMemoryInMegabytes" DATATYPE="Integer">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedDifferenceOfTargetAndTotalServerMemoryInMegabytes = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerMemoryManagerTargetServerMemoryKB.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerMemoryManagerTargetServerMemoryKB = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].CounterObject
            $sSqlInstanceNameForSQLServerMemoryManagerTargetServerMemoryKBWithComputer = "$($CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerMemoryManagerTargetServerMemoryKB"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerMemoryManagerTotalServerMemoryKB.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerMemoryManagerTotalServerMemoryKB = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerMemoryManagerTotalServerMemoryKB[$b].CounterObject
              $sSqlInstanceNameForSQLServerMemoryManagerTotalServerMemoryKBWithComputer = "$($CollectionOfSQLServerMemoryManagerTotalServerMemoryKB[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerMemoryManagerTotalServerMemoryKB"
              If ($sSqlInstanceNameForSQLServerMemoryManagerTargetServerMemoryKBWithComputer -eq $sSqlInstanceNameForSQLServerMemoryManagerTotalServerMemoryKBWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerMemoryManagerTotalServerMemoryKB[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerMemoryManagerTotalServerMemoryKB[$m].Value[$v] -gt 1))
                  {
                    [int]$iDiff = $([double]$CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].Value[$v] - [double]$CollectionOfSQLServerMemoryManagerTotalServerMemoryKB[$m].Value[$v])
                    #// Convert from KB to MB
                    $iDiff = $iDiff / 1024
                    $iDiff = [math]::abs($iDiff)
                  }
                  Else
                  {
                    $iDiff = 0
                  }
                  [void] $blValues.Add($iDiff)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerMemoryManagerTargetServerMemoryKB[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerMemoryManagerTargetServerMemoryKB))\Forwarded Records to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedDifferenceOfTargetAndTotalServerMemoryInMegabytes.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="Target Server memory is more than 500MBs than Total Server Memory" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedDifferenceOfTargetAndTotalServerMemoryInMegabytes -Operator 'gt' -Threshold 500
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Memory Manager\Total Server Memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Memory Manager\Total Server Memory (KB)" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\SQLServer:Memory Manager\Target Server Memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Memory Manager\Target Server Memory(KB)" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\PAL Generated(*)\Difference of Target and Total Server Memory In Megabytes" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\Difference of Target and Total Server Memory In Megabytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedDifferenceOfTargetAndTotalServerMemoryInMegabytes -MinThreshold 500 -MaxThreshold 999.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:Memory Manager Target Server Memory(KB)</B>
<BR>
Total amount of dynamic memory the server is willing to consume]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics Batch Requests/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" ID="{efc7db17-f021-45aa-b31c-7832afe25cf5}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <THRESHOLD NAME="Greater than 1000 batch requests per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerSQLStatisticsBatchRequestssec -Operator 'gt' -Threshold 1000
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfSQLServerSQLStatisticsBatchRequestssec -MinThreshold 1000 -MaxThreshold 1199.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics Batch Requests/sec</B>
<BR>
<B>Description</B> Number of SQL batch requests received by server. This counter measures the number of batch requests that SQL Server receives per second, and generally follows in step to how busy your server's CPUs are. Generally speaking, over 1000 batch requests per second indicates a very busy SQL Server, and could mean that if you are not already experiencing a CPU bottleneck, that you may very well soon. Of course, this is a relative number, and the bigger your hardware, the more batch requests per second SQL Server can handle. From a network bottleneck approach, a typical 100Mbs network card is only able to handle about 3000 batch requests per second. If you have a server that is this busy, you may need to have two or more network cards, or go to a 1Gbs network card. 

Note: Sometimes low batch requests/sec can be misleading.  If there were a SQL statements/sec counter, this would be a more accurate measure of the amount of SQL Server activity.  For example, an application may call only a few stored procedures yet each stored procedure does lot of work.  In that case, we will see a low number for batch requests/sec but each stored procedure (one batch) will execute many SQL statements that drive CPU and other resources.  As a result, many counter thresholds based on the number of batch requests/sec will seem to identify issues because the batch requests on such a server are unusually low for the level of activity on the server.  

We cannot conclude that a SQL Server is not active simply by looking at only batch requests/sec.  Rather, you have to do more investigation before deciding there is no load on the server.  If the average number of batch requests/sec is below 5 and other counters (such as SQL Server processor utilization) confirm the absence of significant activity, then there is not enough of a load to make any recommendations or identify issues regarding scalability.
<BR>
<B>Note:</B> Batch requests / sec is a great counter to use for baselining and to use as a measurement of how many batches the system could handle before a sympton was evident or a particular condition occured. This counter will greatly depend on SQL Server code and the hardware being used. It is often used as a gauge of saying that a particular system was able to handle x number of batch requests per second and then to examine system and SQL Server counters to determine what resource is the bottlneck at that particular workload.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics SQL Compilations/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\SQL Compilations/sec" ID="{d551ab9c-4fb3-4a42-b384-ae8622c5fcc4}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\SQL Compilations/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsSQLCompilationssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\SQL Compilations/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\SQL Compilations/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\SQL Compilations to Batch Requests Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\SQL Compilations to Batch Requests Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedSqlCompilationsToBatchRequestsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedSqlCompilationsToBatchRequestsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerSQLStatisticsSQLCompilationssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec))\SQL Compilations to Batch Requests Ratio Percentage"
              $CollectionOfPalGeneratedSqlCompilationsToBatchRequestsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }          
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 SQL Compilation for every 10 Batch Requests per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedSqlCompilationsToBatchRequestsRatioPercentage -Operator 'gt' -Threshold 10
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\SQL Compilations/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\SQL Compilations/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Batch Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" CHARTLABELS="computer" />
    <CHART CHARTTITLE="\PAL Generated(*)\SQL Compilations to Batch Requests Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\SQL Compilations to Batch Requests Ratio Percentage" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedSqlCompilationsToBatchRequestsRatioPercentage -MinThreshold 1 -MaxThreshold 1.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics SQL Compilations/sec</B><BR>
<B>Description:</B> Number of SQL compilations that occured per second that includes recompiles. A high value subtracting recompiles can be an indication of a large number of ad hoc queries that can also be cross referenced with the number of ad hoc plans in the plan cache counter. 
<BR>
Be aware of the following:
<LI>FORCED PARAMETERIZATION can be set at the database level. This makes SQL Server become much more aggressive in deciding which queries to auto-parameterize. The down-side of this option is that it could potentially introduce parameter-sensitivity problems. (This option was also available in SQL Server 2005).
<LI>OPTIMIZE FOR ADHOC WORKLOADS is a new sp_configure server level option. When set, SQL Server only caches a plan stub on the first execution of an ad-hoc query. The next time the same query is executed, the full plan is stored. Plan stubs are much smaller than query plans and this option ensures that the plan cache is not filled by query plans that have never been reused.
<BR>
<B>Reference</B><BR>
<B>SQL Server, Plan Cache Object</B><BR>
http://msdn.microsoft.com/en-us/library/ms177441(v=sql.105).aspx



]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics SQL Re-Compilations/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\SQL Re-Compilations/sec" ID="{fdae1cbc-6929-416f-8a6f-a1bf7ef04db9}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\SQL Re-Compilations/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsSQLReCompilationssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\SQL Re-Compilations/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\SQL Re-Compilations/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\SQL Compilations/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsSQLCompilationssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\SQL Compilations/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\SQL Compilations/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\SQL Re-Compilations To SQL Compilations Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\SQL Re-Compilations To SQL Compilations Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedSqlReCompilationsToSqlCompilationsRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedSqlReCompilationsToSqlCompilationsRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerSQLStatisticsSQLReCompilationssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerSQLStatisticsSQLReCompilationssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerSQLStatisticsSQLReCompilationssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsSQLReCompilationssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsSQLCompilationssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec"
              If ($sSqlInstanceNameForSQLServerSQLStatisticsSQLReCompilationssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].Value[$v] / [double]$CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$m].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerSQLStatisticsSQLReCompilationssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerSQLStatisticsSQLReCompilationssec))\SQL Re-Compilations To SQL Compilations Ratio Percentage"
              $CollectionOfPalGeneratedSqlReCompilationsToSqlCompilationsRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 SQL Re-Compilation for every 10 SQL Compilations" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedSqlReCompilationsToSqlCompilationsRatioPercentage -Operator 'gt' -Threshold 10
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\SQL Re-Compilations/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\SQL Re-Compilations/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\SQL Compilations/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\SQL Compilations/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\PAL Generated(*)\SQL Re-Compilations To SQL Compilations Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\SQL Re-Compilations To SQL Compilations Ratio Percentage" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedSqlReCompilationsToSqlCompilationsRatioPercentage -MinThreshold 10 -MaxThreshold 29.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics SQL Re-Compilations/sec</B><BR>
<B>Description:</B> Number of SQL re-compiles per second that measures the number of times that a statement executed, but had to be compiled again before the statement completed. There are a variety of reasons that a recompile occured such as statistics being out of date, an column was added to a table a store procedure depends on, statement was run with a recompile option, etc. This counter needs to be as close to 0 as possible. A recompile can cause deadlocks and compile locks that are not compatible with any locking type. 

SQL Server Trace / Profiler provides an execellent way to find out exactly why recompiles are occuring in your environment.
<BR>
<B>Troubleshooting stored procedure recompilation</B><BR> http://support.microsoft.com/kb/243586<BR>
<B>How to identify the cause of recompilation in an SP:Recompile event</B><BR>
http://support.microsoft.com/kb/308737]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Index Searches/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\SQLServer:Access Methods\Index Searches/sec" ID="{c2176a5a-9c52-4805-8775-ffaed10e6571}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Index Searches/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsIndexSearchessec" EXPRESSIONPATH="\SQLServer:Access Methods\Index Searches/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Index Searches/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Full Scans/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsFullScanssec" EXPRESSIONPATH="\SQLServer:Access Methods\Full Scans/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Full Scans/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\Index Searches To Full Scans Ratio Percentage" EXPRESSIONPATH="\PAL Generated(*)\Index Searches To Full Scans Ratio Percentage" COLLECTIONVARNAME="CollectionOfPalGeneratedIndexSearchesToFullScansRatioPercentage" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedIndexSearchesToFullScansRatioPercentage = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerAccessMethodsIndexSearchessec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerAccessMethodsIndexSearchessec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].CounterObject
            $sSqlInstanceNameForSQLServerAccessMethodsIndexSearchessecWithComputer = "$($CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerAccessMethodsIndexSearchessec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerAccessMethodsFullScanssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerAccessMethodsFullScanssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerAccessMethodsFullScanssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerAccessMethodsFullScanssecWithComputer = "$($CollectionOfSQLServerAccessMethodsFullScanssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerAccessMethodsFullScanssec"
              If ($sSqlInstanceNameForSQLServerAccessMethodsIndexSearchessecWithComputer -eq $sSqlInstanceNameForSQLServerAccessMethodsFullScanssecWithComputer)
              {
                $m = $b
              }
            }
            If ($m -ge 0)
            {
              $blValues = New-Object System.Collections.ArrayList
              For ($v=0;$v -lt $CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].Value.Count;$v++)
              {
                If ((IsGreaterThanZero $CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerAccessMethodsFullScanssec[$m].Value[$v]))
                {
                  If (($CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerAccessMethodsFullScanssec[$m].Value[$v] -gt 1))
                  {
                    [int]$iRatio = $([double]$CollectionOfSQLServerAccessMethodsFullScanssec[$m].Value[$v] / [double]$CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].Value[$v]) * 100
                  }
                  Else
                  {
                    $iRatio = 0
                  }
                  [void] $blValues.Add($iRatio)
                }
                Else
                {
                  [void] $blValues.Add(0)
                }
              }
              $sGeneratedInstanceName = "\\$($CollectionOfSQLServerAccessMethodsIndexSearchessec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerAccessMethodsIndexSearchessec))\Index Searches To Full Scans Ratio Percentage"
              $CollectionOfPalGeneratedIndexSearchesToFullScansRatioPercentage.Add($sGeneratedInstanceName,$blValues)
            }
          }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="A ratio of more than 1 SQL Full Scan for every 1000 Index Searches" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedIndexSearchesToFullScansRatioPercentage -Operator 'gt' -Threshold 0.1
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\SQLServer:Access Methods\Full Scans/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Full Scans/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\SQLServer:Access Methods\Index Searches/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Index Searches/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\PAL Generated(*)\Index Searches To Full Scans Ratio Percentage" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\Index Searches To Full Scans Ratio Percentage" CHARTLABELS="computer">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedIndexSearchesToFullScansRatioPercentage -MinThreshold 0.1 -MaxThreshold 0.1999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:Access Methods Full Scans/sec compared to Index/Searches</B>
<BR><B>Description:</B> This counter monitors the number of full scans on base tables or indexes. High values indicate that we may be having performance issues due to table / index page scans. If we see high CPU and / or drops in Page Life Expectancy (PLE) then we need to investigate this counter; however, if full scans are on small tables we can safely ignore this counter as this counter tracks all full table scans, not just those on large tables. A few of the main causes of high Full Scans/sec are missing indexes, too many rows requested, queries with missing indexes, or too many rows requested will have a large number of logical reads and an increased CPU time.
<BR>
This analysis throws a Warning alert if the ratio of Index Searches/sec to Full Scans/sec is less than 1000 to 1 and if there are more than 1000 Index Searches/sec.
<BR>
<B>Note:</B> This counter monitors the number of full scans on tables or indexes. This counter can be ignored unless there is also high CPU use along with high scan rates. High scan rates may be caused by missing indexes, very small tables, or requests for too many records. 
<BR><B>Threshold: </B>
<BR>Yellow: A ratio of more than 1 full scan for every 1000 index searches. The value of Index Searches/sec and Full Scans/sec should be greater than 1000.
<BR><BR>Formula: 
(AvgSQLServerAccessMethodsIndexSearchessecAll / AvgSQLServerAccessMethods_FullScanssec) < 1000
<BR><BR><B>Next Steps:</B>
The main causes of high Full Scans/sec are:
<LI>Missing indexes
<LI>Too many rows requested
Queries with missing indexes or too many rows requested will have a large number of logical reads and an increased CPU time. As mentioned, if there is a high level of Full Scans to Index Searches, then it is important to also check the following:
See PERFMON SQLServer:Buffer Manager performance counters for memory pressure:
<LI>Page Life Expectancy
<LI>Checkpoint pages/sec
<LI>Lazy writes/sec
A high number of scans can cause buffer pool pressure (as indicated with low PLE and a higher Lazy Writes / sec count).
Memory pressure will quickly manifest into disk pressure, so also check:
See PERFMON Physical Disk performance counters: 
<LI>Disk sec/read
<LI>Disk sec/write
Note: Identify disk bottlenecks by using Performance Counters, Profiler, sys.dm_io_virtual_file_stats and SHOWPLAN output.
Also refer to the sys.dm_io_virtual_file_stats dynamic management view (DMV) to track io_stalls to help identify IO bottlenecks. 
To back up and support this information, compare the counters to sys.dm_os_wait_stats output. If you see high values in perfmon, you may also see high waits for the following:
<LI>ASYNC_IO_COMPLETION
<LI>IO_COMPLETION
<LI>PAGEIOLATCH_* (Data page I/O completion waits appear as PAGEIOLATCH_* waits)
Reactively, SQL Profiler can be used to identify which SQL statements are causing scans. Use the scans event class and events scan:started and scan:completed. Include the object ID data column. Save the profiler trace to a file and then convert it to trace table. You can then search for the scans event. 
The scan:completed event provides the associated IO so that you can also search for high reads, writes, and duration.
<BR><B>Reference:</B>
<BR><B>SQL Server, Access Methods Object</B>
http://msdn.microsoft.com/en-us/library/ms177426.aspx 
<BR><B>SQL Server 2005 Waits and Queues</B>
http://download.microsoft.com/download/4/7/a/47a548b9-249e-484c-abd7-29f31282b04d/Performance_Tuning_Waits_Queues.doc 
<BR><B>Wait Types and Correlation to Other Performance Info</B>
http://www.sqlmag.com/Files/09/40925/Webtable_01.doc]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Locks Lock Requests/sec" ENABLED="True" CATEGORY="SQLServer:Locks" PRIMARYDATASOURCE="\SQLServer:Locks(*)\Lock Requests/sec" ID="{fc1381df-3e10-4cbd-abaa-be3db8d8ba11}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Locks(*)\Lock Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerLocksLockRequestssec" EXPRESSIONPATH="\SQLServer:Locks(*)\Lock Requests/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Locks(*)\Lock Requests/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Locks(*)\Lock Requests/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Locks(*)\Lock Requests/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Lock Requests/sec Greater than 1000" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerLocksLockRequestssec -Operator 'gt' -Threshold 1000

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Locks Lock Requests/sec</B>
<BR>
<B>Description:</B> Number of new locks and lock conversions requested from the lock manager. This value should tie close to the number of Batch Requests per second. Values greaters than 1000 may indicate queries are pulling large volumes of data thereby accessing large numbers of rows</B>
<BR>
<B>Threshold</B>
<BR>
<B>Yellow</B> Greater than > 1000 Lock Requests / sec]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Locks Lock Waits/sec" ENABLED="True" CATEGORY="SQLServer:Locks" PRIMARYDATASOURCE="\SQLServer:Locks(*)\Lock Waits/sec" ID="{13d7299f-661c-4c31-a08f-be1031a22bd1}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Locks(*)\Lock Waits/sec" COLLECTIONVARNAME="CollectionOfSQLServerLocksLockWaitssec" EXPRESSIONPATH="\SQLServer:Locks(*)\Lock Waits/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Locks(*)\Lock Waits/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Locks(*)\Lock Waits/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Locks(*)\Lock Waits/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerLocksLockWaitssec -Operator 'gt' -Threshold 0

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Locks Lock Waits/sec</B>
<BR><B>Description: </B> Number of lock requests that could not be satisfied immediately and required the caller to wait before being granted the lock. This is a sign that there is some blocking occuring and would be a good baseline measurement of lock waits for load testing.
<BR><B>Note: </B> Lock waits are not recorded by until after the lock event completes. For examining active blocking it is recommended to query sys.dm_os_waiting_tasks.
<BR>
<B>Threshold</B><BR>
<B>Yellow</B> Values greater than 0]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Locks Lock Wait Time (ms)" ENABLED="True" CATEGORY="SQLServer:Locks" PRIMARYDATASOURCE="\SQLServer:Locks(*)\Lock Wait Time (ms)" ID="{d7f36b5a-ff47-4d56-b3af-81160b3f22e0}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Locks(*)\Lock Wait Time (ms)" COLLECTIONVARNAME="CollectionOfSQLServerLocksLockWaitTimems" EXPRESSIONPATH="\SQLServer:Locks(*)\Lock Wait Time (ms)" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Locks(*)\Lock Wait Time (ms)" DATATYPE="Round3" />
    <CHART CHARTTITLE="\SQLServer:Locks(*)\Lock Wait Time (ms)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Locks(*)\Lock Wait Time (ms)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Total wait time (milliseconds) for locks in the last second.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Locks Lock Timeouts/sec" ENABLED="True" CATEGORY="SQLServer:Locks" PRIMARYDATASOURCE="\SQLServer:Locks(*)\Lock Timeouts/sec" ID="{78a24ae5-3480-4582-b314-bb0e77b13342}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Locks(*)\Lock Timeouts/sec" COLLECTIONVARNAME="CollectionOfSQLServerLocksLockTimeoutstimeoutsec" EXPRESSIONPATH="\SQLServer:Locks(*)\Lock Timeouts/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Locks(*)\Lock Timeouts/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Locks(*)\Lock Timeouts/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Locks(*)\Lock Timeouts/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater Than &gt; 1" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[#// Use PowerShell code to create alerts when the conditions for this threshold are met.
#// Optionally use the variables listed above in the Variables list box.
#// If the condition for this threshold is a static value, then use the StaticThreshold() function.
#// Otherwise, you will need to manually loop through the counter instance collection object.
#// The counter instance collection object has a unique name for each counter data source in this analysis.
#// See the variables in the Variables list box above for more information on the counter instance collection object.

#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerLocksLockTimeoutstimeoutsec -Operator 'gt' -Threshold 1

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Locks Lock Timeouts/sec</B><BR>
<B>Description:</B> Number of lock requests that timed out. This does not include requests for NOWAIT locks. A value greater than zero might indicate that user queries are not completing.
<BR>
<B>Threshold</B><BR>
<B>Yellow</B> Greater than >1

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Locks Number of Deadlocks/sec" ENABLED="True" CATEGORY="SQLServer:Locks" PRIMARYDATASOURCE="\SQLServer:Locks(*)\Number of Deadlocks/sec" ID="{45d8c053-69d7-4257-9092-65adb682b628}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Locks(*)\Number of Deadlocks/sec" COLLECTIONVARNAME="CollectionOfSQLServerLocksNumberofDeadlockssec" EXPRESSIONPATH="\SQLServer:Locks(*)\Number of Deadlocks/sec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Locks(*)\Number of Deadlocks/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Locks(*)\Number of Deadlocks/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Locks(*)\Number of Deadlocks/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Deadlocks Greater than 0" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerLocksNumberofDeadlockssec -Operator 'gt' -Threshold 0

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Locks Number of Deadlocks/sec</B><BR>
<B>Description:</B><BR>
Number of lock requests, per second, which resulted in a deadlock. Deadlocks are always an issue that should be resolved. A deadlock transaction that is killed must be rerun. It is recommended to use the SQL Trace deadlock graph, trace flag 1222, and the extended events deadlock capture to help identify and solve all of the deadlocks in your environment.
<BR>
<B>Threshold</B><BR>
<B>Red</B> Any Deadlocks greater than 0
<BR>
<B>Resources</B>
<BR><B>Bart Duncan Deadlock Resources</B><LI>Part 1 - http://blogs.msdn.com/b/bartd/archive/2006/09/09/deadlock-troubleshooting_2c00_-part-1.aspx
<LI>Part 2 - http://blogs.msdn.com/b/bartd/archive/2006/09/13/751343.aspx
<LI>Part 3 - http://blogs.msdn.com/b/bartd/archive/2006/09/25/770928.aspx
<BR>
<B>Getting historical deadlock info using extended events</B><BR>
http://www.sqlskills.com/BLOGS/PAUL/post/Getting-historical-deadlock-info-using-extended-events.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Latches\Total Latch Wait Time (ms)" ENABLED="True" CATEGORY="SQLServer:Latches" PRIMARYDATASOURCE="\SQLServer:Latches\Total Latch Wait Time (ms)" ID="{e02e1ef5-8982-49da-bb72-932bc966235f}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Latches\Total Latch Wait Time (ms)" COLLECTIONVARNAME="SQLServerLatchesTotalLatchWaitTimems" EXPRESSIONPATH="\SQLServer:Latches\Total Latch Wait Time (ms)" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Latches\Total Latch Wait Time (ms)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Latches\Total Latch Wait Time (ms)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Latches\Total Latch Wait Time (ms)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Latches\Total Latch Wait Time (ms)</B>
<BR>
Total latch wait time (milliseconds) for latch requests that had to wait in the last second.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process % Processor Time" ENABLED="False" CATEGORY="Process" PRIMARYDATASOURCE="\Process(sqlservr)\% Processor Time" ID="e8b760f8-6f7f-479a-ac57-fe897323bd46" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(sqlservr)\% Processor Time" COLLECTIONVARNAME="CollectionOfProcessPercentProcessorTime" EXPRESSIONPATH="\Process(sqlservr)\% Processor Time" TRENDVARNAME="TrendProcessPercentProcessorTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(sqlservr)\% Processor Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(sqlservr)\% Processor Time" CHARTLABELS="instance" />
    <THRESHOLD NAME="SQL Server is using more than 80% of AVG CPU usage" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[         StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessPercentProcessorTime -Operator 'gt' -Threshold 80
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>\Process % Processor Time / Process(sqlservr)\% Processor Time</B>
<BR>
<BR>
<B>Description:</B>
% Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this counter.

This counter measures the percentage of total processor time spent (user mode and kernel mode) on SQL Server process threads. If this counter stays at 80% for sustained periods of time, then you may also wish to investigate other Process (sqlservr) such as Private Bytes, Virtual Bytes, and Working Set to get a better understanding of how SQL Server allocates certain segments of memory. 

<BR>
<B>Threshold:</B>
<BR><B>Red:</B> SQL Server is using more than 30% user mode CPU usage

<BR>
<B>Reference:</B>
<BR>
<B>Monitoring CPU Usage</B><BR>
http://msdn.microsoft.com/en-us/library/ms178072.aspx 
<BR><B>Ask the Performance Team</B>
http://blogs.technet.com/askperf/archive/2008/01/18/do-you-know-where-your-processor-spends-its-time.aspx 
<BR><B>Clint Huffman's Windows Troubleshooting in the Field Blog</B>
http://blogs.technet.com/clinth/archive/2009/10/28/the-case-of-the-2-million-context-switches.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Memory Manager Memory Grants Outstanding" ENABLED="True" CATEGORY="SQLServer:Memory Manager" PRIMARYDATASOURCE="\SQLServer:Memory Manager\Memory Grants Outstanding" ID="f2a8ede2-909b-46d6-9607-d009a908b907" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Memory Manager\Memory Grants Outstanding" COLLECTIONVARNAME="CollectionOfSQLServerMemoryManagerMemoryGrantsOutstanding" EXPRESSIONPATH="\SQLServer:Memory Manager\Memory Grants Outstanding" TRENDVARNAME="TrendSQLServerMemoryManagerMemoryGrantsOutstanding" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Memory Manager\Memory Grants Outstanding" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Memory Manager\Memory Grants Outstanding" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Memory Manager\Memory Grants Outstanding" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Memory Manager Memory Grants Outstanding</B>
<BR>
Total number of processes per second that have successfully acquired a workspace memory grant. This counter should be used as a baseline for comparisons under load.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Memory Manager\Granted Workspace Memory  Granted Workspace Memory (KB)" ENABLED="True" CATEGORY="SQLServer:Memory Manager" PRIMARYDATASOURCE="\SQLServer:Memory Manager\Granted Workspace Memory (KB)" ID="c9c01c8b-b9bf-4a0b-b3b2-8fc0d491c385" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Memory Manager\Granted Workspace Memory (KB)" COLLECTIONVARNAME="CollectionOfSQLServerMemoryManagerGrantedWorkspaceMemoryGrantedWorkspaceMemoryKB" EXPRESSIONPATH="\SQLServer:Memory Manager\Granted Workspace Memory (KB)" TRENDVARNAME="TrendSQLServerMemoryManagerGrantedWorkspaceMemoryGrantedWorkspaceMemoryKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Memory Manager\Granted Workspace Memory (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Memory Manager\Granted Workspace Memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Memory Manager\Granted Workspace Memory (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Memory Manager\Granted Workspace Memory  Granted Workspace Memory (KB)</B>
<BR>
Total amount of memory granted to executing processes. This memory is used for hash, sort and create index operations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Memory Manager\Maximum Workspace Memory  Maximum Workspace Memory (KB)" ENABLED="True" CATEGORY="SQLServer:Memory Manager" PRIMARYDATASOURCE="\SQLServer:Memory Manager\Maximum Workspace Memory (KB)" ID="93ca34a3-2bfd-4cdf-ab81-fd02e2fc432d" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Memory Manager\Maximum Workspace Memory (KB)" COLLECTIONVARNAME="CollectionOfSQLServerMemoryManagerMaximumWorkspaceMemoryMaximumWorkspaceMemoryKB" EXPRESSIONPATH="\SQLServer:Memory Manager\Maximum Workspace Memory (KB)" TRENDVARNAME="TrendSQLServerMemoryManagerMaximumWorkspaceMemoryMaximumWorkspaceMemoryKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Memory Manager\Maximum Workspace Memory (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Memory Manager\Maximum Workspace Memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Memory Manager\Maximum Workspace Memory (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Memory Manager\Maximum Workspace Memory  Maximum Workspace Memory (KB)</B>
<BR>
Total amount of memory granted to executing processes. This memory is used primarily for hash, sort and create index operations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Data File(s) Size (KB)" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Data File(s) Size (KB)" ID="6b1d393d-669f-41e8-beae-aa88a9c3bf03" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Data File(s) Size (KB)" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesDataFilesSizeKB" EXPRESSIONPATH="\SQLServer:Databases(*)\Data File(s) Size (KB)" TRENDVARNAME="TrendSQLServerDatabasesDataFilesSizeKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Data File(s) Size (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Data File(s) Size (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Data File(s) Size (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[The cumulative size of all the data files in the database.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Bytes Flushed/sec" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Bytes Flushed/sec" ID="04647d97-6d5f-4410-8805-72282cb9c024" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[Total number of log bytes flushed.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Bytes Flushed/sec" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogBytesFlushedsec" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Bytes Flushed/sec" TRENDVARNAME="TrendSQLServerDatabasesLogBytesFlushedsec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Bytes Flushed/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Bytes Flushed/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Bytes Flushed/sec" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log File(s) Size (KB)" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log File(s) Size (KB)" ID="e492600e-3d9e-46ec-a4e0-2ab0e7250031" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[The cumulative size of all the log files in the database.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log File(s) Size (KB)" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogFilesSizeKB" EXPRESSIONPATH="\SQLServer:Databases(*)\Log File(s) Size (KB)" TRENDVARNAME="TrendSQLServerDatabasesLogFilesSizeKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log File(s) Size (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log File(s) Size (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log File(s) Size (KB)" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log File(s) Used Size (KB)" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log File(s) Used Size (KB)" ID="f56fc228-608b-4c61-bbc9-5aed60793e0c" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[The cumulative used size of all the log files in the database.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log File(s) Used Size (KB)" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogFilesUsedSizeKB" EXPRESSIONPATH="\SQLServer:Databases(*)\Log File(s) Used Size (KB)" TRENDVARNAME="TrendSQLServerDatabasesLogFilesUsedSizeKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log File(s) Used Size (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log File(s) Used Size (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log File(s) Used Size (KB)" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Flush Wait Time" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Flush Wait Time" ID="87328d38-f64c-4116-907d-54d78505a0df" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Flush Wait Time" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogFlushWaitTime" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Flush Wait Time" TRENDVARNAME="TrendSQLServerDatabasesLogFlushWaitTime" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Flush Wait Time" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Flush Wait Time" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Flush Wait Time" CHARTLABELS="instance" />
    <THRESHOLD NAME="Log Flush Wait Time - Near 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerDatabasesLogFlushWaitTime -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Total wait time (milliseconds).]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Flush Waits/sec" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Flush Waits/sec" ID="f99bcffa-545d-46d5-8678-5d81ca515633" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Flush Waits/sec" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogFlushWaitssec" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Flush Waits/sec" TRENDVARNAME="TrendSQLServerDatabasesLogFlushWaitssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Flush Waits/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Flush Waits/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Flush Waits/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Log Flush Waits/sec Near 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerDatabasesLogFlushWaitssec -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Number of commits waiting on log flush.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Flushes/sec" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Flushes/sec" ID="fbfe59a7-da3e-4868-897d-81241bdda1c0" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[Number of log flushes.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Flushes/sec" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogFlushessec" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Flushes/sec" TRENDVARNAME="TrendSQLServerDatabasesLogFlushessec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Flushes/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Flushes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Flushes/sec" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Growths" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Growths" ID="0da97d94-6885-4e90-bd24-1b47b1a953cc" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Growths" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogGrowths" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Growths" TRENDVARNAME="TrendSQLServerDatabasesLogGrowths" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Growths" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Growths" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Growths" CHARTLABELS="instance" />
    <THRESHOLD NAME="Log Growths Near 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerDatabasesLogGrowths -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Total number of log growths for this database.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Truncations" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Truncations" ID="22f2eae1-af61-4841-b83f-32846dd2c16a" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[Total number of log truncations for this database.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Truncations" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogTruncations" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Truncations" TRENDVARNAME="TrendSQLServerDatabasesLogTruncations" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Truncations" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Truncations" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Truncations" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Log Shrinks" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Log Shrinks" ID="459e4d53-c15d-4521-81c8-2a3e4e1addf5" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Log Shrinks" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesLogShrinks" EXPRESSIONPATH="\SQLServer:Databases(*)\Log Shrinks" TRENDVARNAME="TrendSQLServerDatabasesLogShrinks" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Log Shrinks" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Log Shrinks" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Log Shrinks" CHARTLABELS="instance" />
    <THRESHOLD NAME="Log Shrinks Near 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerDatabasesLogShrinks -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Total number of log shrinks for this database.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Databases Percent Log Used" ENABLED="True" CATEGORY="SQLServer:Databases" PRIMARYDATASOURCE="\SQLServer:Databases(*)\Percent Log Used" ID="0b515056-6ea8-4e78-9e05-506b2bbeeae4" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Databases(*)\Percent Log Used" COLLECTIONVARNAME="CollectionOfSQLServerDatabasesPercentLogUsed" EXPRESSIONPATH="\SQLServer:Databases(*)\Percent Log Used" TRENDVARNAME="TrendSQLServerDatabasesPercentLogUsed" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Databases(*)\Percent Log Used" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Databases(*)\Percent Log Used" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Databases(*)\Percent Log Used" CHARTLABELS="instance" />
    <THRESHOLD NAME="Percent Log Used - Less than 80%" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerDatabasesPercentLogUsed -Operator 'gt' -Threshold 80]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[The percent of space in the log that is in use.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics Auto-Param Attempts/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\Auto-Param Attempts/sec" ID="aeca4a67-595e-4f2d-ac26-0b64349c11ff" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Auto-Param Attempts/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsAutoParamAttemptssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Auto-Param Attempts/sec" TRENDVARNAME="TrendSQLServerSQLStatisticsAutoParamAttemptssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Auto-Param Attempts/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Auto-Param Attempts/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Auto-Param Attempts/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics Auto-Param Attempts/sec</B>
<BR>
Number of auto-parameterization attempts.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics Failed Auto-Params/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\Failed Auto-Params/sec" ID="9eea431b-ee1a-4d45-84aa-626698de7d8b" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Failed Auto-Params/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsFailedAutoParamssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Failed Auto-Params/sec" TRENDVARNAME="TrendSQLServerSQLStatisticsFailedAutoParamssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Failed Auto-Params/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Failed Auto-Params/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Failed Auto-Params/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics Failed Auto-Params/sec</B>
<BR>
Number of failed auto-parameterizations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics Safe Auto-Params/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\Safe Auto-Params/sec" ID="111640f6-0ec8-4d89-839a-d5b194305223" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Safe Auto-Params/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsSafeAutoParamssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Safe Auto-Params/sec" TRENDVARNAME="TrendSQLServerSQLStatisticsSafeAutoParamssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Safe Auto-Params/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Safe Auto-Params/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Safe Auto-Params/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Number of safe auto-parameterizations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics Unsafe Auto-Params/sec" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\Unsafe Auto-Params/sec" ID="c1dee86a-8306-488e-9a06-64e24d1db55a" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Unsafe Auto-Params/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsUnsafeAutoParamssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Unsafe Auto-Params/sec" TRENDVARNAME="TrendSQLServerSQLStatisticsUnsafeAutoParamssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Unsafe Auto-Params/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\Unsafe Auto-Params/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\Unsafe Auto-Params/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics Unsafe Auto-Params/sec</B>
<BR>
Number of unsafe auto-parameterizations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Workload Group Stats CPU usage %" ENABLED="True" CATEGORY="SQLServer:Workload Group Stats" PRIMARYDATASOURCE="\SQLServer:Workload Group Stats(*)\CPU usage %" ID="d8bddf04-3c12-4a9f-b32c-1bcfa5761f12" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Workload Group Stats(*)\CPU usage %" COLLECTIONVARNAME="CollectionOfSQLServerWorkloadGroupStatsCPUusagePercent" EXPRESSIONPATH="\SQLServer:Workload Group Stats(*)\CPU usage %" TRENDVARNAME="TrendSQLServerWorkloadGroupStatsCPUusagePercent" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Workload Group Stats(*)\CPU usage %" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Workload Group Stats(*)\CPU usage %" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Workload Group Stats(*)\CPU usage %" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[System CPU usage by all requests in the specified instance of the performance object.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Workload Group Stats Requests completed/sec" ENABLED="True" CATEGORY="SQLServer:Workload Group Stats" PRIMARYDATASOURCE="\SQLServer:Workload Group Stats(*)\Requests completed/sec" ID="4cc58bd6-695a-4829-a895-c7440175aa3f" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Workload Group Stats(*)\Requests completed/sec" COLLECTIONVARNAME="CollectionOfSQLServerWorkloadGroupStatsRequestscompletedsec" EXPRESSIONPATH="\SQLServer:Workload Group Stats(*)\Requests completed/sec" TRENDVARNAME="TrendSQLServerWorkloadGroupStatsRequestscompletedsec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Workload Group Stats(*)\Requests completed/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Workload Group Stats(*)\Requests completed/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Workload Group Stats(*)\Requests completed/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Number of completed requests per second in the workload group.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Workload Group Stats Queued requests" ENABLED="True" CATEGORY="SQLServer:Workload Group Stats" PRIMARYDATASOURCE="\SQLServer:Workload Group Stats(*)\Queued requests" ID="52ff4c08-3b88-40e9-82dc-28979ffd28b1" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Workload Group Stats(*)\Queued requests" COLLECTIONVARNAME="CollectionOfSQLServerWorkloadGroupStatsQueuedrequests" EXPRESSIONPATH="\SQLServer:Workload Group Stats(*)\Queued requests" TRENDVARNAME="TrendSQLServerWorkloadGroupStatsQueuedrequests" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Workload Group Stats(*)\Queued requests" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Workload Group Stats(*)\Queued requests" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Workload Group Stats(*)\Queued requests" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Number of requests waiting in the queue due to resource governor limits in the workload group.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Resource Pool Stats CPU usage %" ENABLED="True" CATEGORY="SQLServer:Resource Pool Stats" PRIMARYDATASOURCE="\SQLServer:Resource Pool Stats(*)\CPU usage %" ID="a12c752c-3d6c-483e-951f-8a876684e5f9" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Resource Pool Stats(*)\CPU usage %" COLLECTIONVARNAME="CollectionOfSQLServerResourcePoolStatsCPUusagePercent" EXPRESSIONPATH="\SQLServer:Resource Pool Stats(*)\CPU usage %" TRENDVARNAME="TrendSQLServerResourcePoolStatsCPUusagePercent" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Resource Pool Stats(*)\CPU usage %" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Resource Pool Stats(*)\CPU usage %" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Resource Pool Stats(*)\CPU usage %" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[System CPU usage by all requests in the specified instance of the performance object.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Resource Pool Stats Target memory (KB)" ENABLED="True" CATEGORY="SQLServer:Resource Pool Stats" PRIMARYDATASOURCE="\SQLServer:Resource Pool Stats(*)\Target memory (KB)" ID="48618f5f-f06b-4102-8c2c-ba2a867912ba" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Resource Pool Stats(*)\Target memory (KB)" COLLECTIONVARNAME="CollectionOfSQLServerResourcePoolStatsTargetmemoryKB" EXPRESSIONPATH="\SQLServer:Resource Pool Stats(*)\Target memory (KB)" TRENDVARNAME="TrendSQLServerResourcePoolStatsTargetmemoryKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Resource Pool Stats(*)\Target memory (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Resource Pool Stats(*)\Target memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Resource Pool Stats(*)\Target memory (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Target amount of memory in kilobytes the resource pool is trying to attain based on the settings and server state.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Resource Pool Stats Used memory (KB)" ENABLED="True" CATEGORY="SQLServer:Resource Pool Stats" PRIMARYDATASOURCE="\SQLServer:Resource Pool Stats(*)\Used memory (KB)" ID="30abd1bf-3bc0-4d34-8f6e-0df85f417f4c" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Resource Pool Stats(*)\Used memory (KB)" COLLECTIONVARNAME="CollectionOfSQLServerResourcePoolStatsUsedmemoryKB" EXPRESSIONPATH="\SQLServer:Resource Pool Stats(*)\Used memory (KB)" TRENDVARNAME="TrendSQLServerResourcePoolStatsUsedmemoryKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Resource Pool Stats(*)\Used memory (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Resource Pool Stats(*)\Used memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Resource Pool Stats(*)\Used memory (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Used amount of memory in kilobytes in the resource pool.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Free list stalls/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Free list stalls/sec" ID="15f97b53-4ebf-4b4d-a21d-4895bd40c5d8" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Free list stalls/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerFreeliststallssec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Free list stalls/sec" TRENDVARNAME="TrendSQLServerBufferManagerFreeliststallssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Free list stalls/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Free list stalls/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Free list stalls/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Free list stalls/sec &gt; 2" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerFreeliststallssec -Operator 'gt' -Threshold 2]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Buffer Manager Free list stalls/sec</B>
<BR>
<B>Description:</B> Number of requests that had to wait for a free page.

Free list stalls/sec is the frequency with which requests for available database pages are suspended because no buffers are available. Free list stall rates of greater than 2 per second indicate too little SQL memory available.

<BR><B>Reference</B><BR>
<B>Threshold</B><BR>
Yellow - Free list stalls/sec > 2 <BR>
<B>SQL Server, Buffer Manager Object</B>
<BR>
http://technet.microsoft.com/en-us/library/ms189628.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Checkpoint pages/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Checkpoint pages/sec" ID="1efe1f78-f82d-4b3f-9c20-6f52ed77f0c0" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Checkpoint pages/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerCheckpointpagessec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Checkpoint pages/sec" TRENDVARNAME="TrendSQLServerBufferManagerCheckpointpagessec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Checkpoint pages/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Checkpoint pages/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Checkpoint pages/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Buffer Manager Checkpoint pages/sec</B>
<BR>
<B>Description</B>
<BR>
Number of pages, per second, flushed by checkpoint or other operations that require all dirty pages to be flushed. The checkpoint frequency can be due to low memory conditions as well as the recovery interval set by sp_configure.
<BR>
<B>Reference</B>
<BR>
<B>SQL Server, Buffer Manager Object</B>
<BR>http://msdn.microsoft.com/en-us/library/ms189628.aspx
<BR>
<B>A SQL Server DBA myth a day: (15/30) checkpoint only writes pages from committed transactions</B>
<BR>http://www.sqlskills.com/BLOGS/PAUL/category/Checkpoint.aspx
<BR>
<B>Database Checkpoints (SQL Server)</B>
<BR>
http://technet.microsoft.com/en-us/library/ms189573(v=sql.110).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Readahead pages/sec" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Readahead pages/sec" ID="81347d5b-2710-44d1-aff8-76052241656a" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Readahead pages/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerReadaheadpagessec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Readahead pages/sec" TRENDVARNAME="TrendSQLServerBufferManagerReadaheadpagessec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Readahead pages/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Readahead pages/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Readahead pages/sec" CHARTLABELS="instance" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Page reads/sec" EXPRESSIONPATH="\SQLServer:Buffer Manager\Page reads/sec" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerPagereadssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Page reads/sec" DATATYPE="integer" />
    <THRESHOLD NAME="&lt; 20% of Page Reads/sec" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferManagerPagereadssec -Operator 'gt' -Threshold 20
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Buffer Manager Readahead pages/sec</B>

<BR><BR><B>Description:</B> Number of pages read, in second, in anticipation of use which is an optimistic physical read. This number should not exceed greater than 20% of total page reads.<BR>
<B>Threshold:</B>
<BR><B>Yellow:</B>< 20% of Page Reads/sec
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Manager Stolen pages" ENABLED="True" CATEGORY="SQLServer:Buffer Manager" PRIMARYDATASOURCE="\SQLServer:Buffer Manager\Stolen pages" ID="bd12b504-f4e1-4b88-829f-9ab8fdad5e7e" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Manager\Stolen pages" COLLECTIONVARNAME="CollectionOfSQLServerBufferManagerStolenpages" EXPRESSIONPATH="\SQLServer:Buffer Manager\Stolen pages" TRENDVARNAME="TrendSQLServerBufferManagerStolenpages" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Manager\Stolen pages" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Manager\Stolen pages" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Manager\Stolen pages" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>\SQLServer:Buffer Manager Stolen pages</B>

<BR><B>Description:</B> Number of pages used for miscellaneous server purposes (including procedure cache). This counter shows how many pages were taken from the buffer pool to accomodate non-buffer pool needs such as plan cache, procedure cache, the optimizer, workspace memory, etc. This counter should be baselined and can be analyzed by comparing this counter to the amount of buffer pool space and large requests that are hitting the SQL Server instance.

<BR><B>Note:</B> DBCC MEMORYSTATUS can also be leveraged to examine the impact of stolen memory to the buffer pool.
<BR><B>Note:</B> The lazywriter process is not permitted to flush Stolen buffers out of the buffer pool. 

<BR><B>Reference:</B><BR> 
<B>SQL Server, Buffer Manager Object</B>
<BR>
http://technet.microsoft.com/en-us/library/ms189628(v=sql.105).aspx<BR>
<B>INF: Using DBCC MEMORYSTATUS to Monitor SQL Server Memory Usage</B>
<BR>
http://support.microsoft.com/kb/271624]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Deprecated Features Usage" ENABLED="True" CATEGORY="SQLServer:Deprecated Features" PRIMARYDATASOURCE="\SQLServer:Deprecated Features(*)\Usage" ID="0c08c20c-38fc-46e6-b1c5-0aebfa8e0279" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Deprecated Features(*)\Usage" COLLECTIONVARNAME="CollectionOfSQLServerDeprecatedFeaturesUsage" EXPRESSIONPATH="\SQLServer:Deprecated Features(*)\Usage" TRENDVARNAME="TrendSQLServerDeprecatedFeaturesUsage" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Deprecated Features(*)\Usage" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Deprecated Features(*)\Usage" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Deprecated Features(*)\Usage" CHARTLABELS="instance" />
    <THRESHOLD NAME="Deprecated Usage - Near 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerDeprecatedFeaturesUsage -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Deprecated Features Usage</B>
<BR>
Feature usage since last SQL Server startup
<BR>
You can also examine performance counters through the sys.dm_os_performance_counters DMV. By using the perfmon counters for deprecation and the DMVs, you can help your application prepare and avoid issue when migrating to the future versions of SQL Server.

SELECT * FROM sys.dm_os_performance_counters
WHERE object_name LIKE '%Deprecated Features%'AND cntr_value > 0
ORDER BY cntr_value DESC
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Statistics SQL Attention rate" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\SQL Attention rate" ID="f9aee944-d104-4436-89e7-5cf7dc383013" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\SQL Attention rate" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsSQLAttentionrate" EXPRESSIONPATH="\SQLServer:SQL Statistics\SQL Attention rate" TRENDVARNAME="TrendSQLServerSQLStatisticsSQLAttentionrate" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\SQL Attention rate" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SQL Statistics\SQL Attention rate" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Statistics\SQL Attention rate" CHARTLABELS="instance" />
    <THRESHOLD NAME="Attention Rate Greater Than 0" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerSQLStatisticsSQLAttentionrate -Operator 'gt' -Threshold 0

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Statistics SQL Attention rate</B>
<BR>
Number of attentions per second. Attentions are the number of user cancels and query timeout that occured per second. A high number of attentions may indicate slow query performance as users are cancelling queries.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SQL Errors Errors/sec" ENABLED="True" CATEGORY="SQLServer:SQL Errors" PRIMARYDATASOURCE="\SQLServer:SQL Errors(*)\Errors/sec" ID="941ea730-860b-403f-ad5c-ed362f2473aa" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Errors(*)\Errors/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLErrorsErrorssec" EXPRESSIONPATH="\SQLServer:SQL Errors(*)\Errors/sec" TRENDVARNAME="TrendSQLServerSQLErrorsErrorssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Errors(*)\Errors/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SQL Errors(*)\Errors/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SQL Errors(*)\Errors/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Number of errors/sec]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Plan Cache Cache Hit Ratio" ENABLED="True" CATEGORY="SQLServer:Plan Cache" PRIMARYDATASOURCE="\SQLServer:Plan Cache(*)\Cache Hit Ratio" ID="6c59781f-e81c-4a27-9290-4eefaf35fb57" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Plan Cache(*)\Cache Hit Ratio" COLLECTIONVARNAME="CollectionOfSQLServerPlanCacheCacheHitRatio" EXPRESSIONPATH="\SQLServer:Plan Cache(*)\Cache Hit Ratio" TRENDVARNAME="TrendSQLServerPlanCacheCacheHitRatio" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Plan Cache(*)\Cache Hit Ratio" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Plan Cache(*)\Cache Hit Ratio" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Plan Cache(*)\Cache Hit Ratio" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Plan Cache Cache Hit Ratio</B><BR>
<B>Description</B> Ratio between cache hits and lookups

The Plan Cacheobject provides counters to monitor how SQL Server uses memory to store objects such as stored procedures, ad hoc and prepared Transact-SQL statements, and triggers. Multiple instances of the Plan Cache object can be monitored at the same time, with each instance representing a different type of plan to monitor.
<BR><BR><B>Compiled Plan Stubs & Plan Cache Perf Counters:</B>
<LI>Cache Pages: Reports pages for compiled plans and compiled plan stubs
<LI>Cache Object Count: Includes compiled plans stubs
<LI>Cache Hit Ratio: Not incremented for compiled plan stub hits
<BR><BR>
In SQL Server 2008 R2, there are three options that can help in dealing with plan cache pollution issues.
<LI>FORCED PARAMETERIZATION can be set at the database level. This makes SQL Server become much more aggressive in deciding which queries to auto-parameterize. The down-side of this option is that it could potentially introduce parameter-sensitivity problems. (This option was also available in SQL Server 2005).
<LI>OPTIMIZE FOR ADHOC WORKLOADS is a new sp_configure server level option. When set, SQL Server only caches a plan stub on the first execution of an ad-hoc query. The next time the same query is executed, the full plan is stored. Plan stubs are much smaller than query plans and this option ensures that the plan cache is not filled by query plans that have never been reused.
<LI>DBCC FREESYSTEMCACHE can be used to clear the cache of plans associated with a particular Resource Governor resource pool. This could be useful when executed periodically if ad-hoc queries are able to be isolated into identifiable resource pools. (This command was also available in SQL Server 2005 but the option to clear a specific resource pool was added in SQL Server 2008).
<BR>
<B>Contributor(s):</B><BR>
<LI><B>Pedro Lopes - </B></LI>
Pedro.Lopes@microsoft.com
<BR>
<B>Reference:</B><BR>
<B>SQL Server, Plan Cache Object</B><BR>
http://msdn.microsoft.com/en-us/library/ms177441(v=sql.105).aspx




]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Locks Average Wait Time (ms)" ENABLED="True" CATEGORY="SQLServer:Locks" PRIMARYDATASOURCE="\SQLServer:Locks(*)\Average Wait Time (ms)" ID="f88c23fd-1211-40b5-a79b-e8e1906c2052" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Locks(*)\Average Wait Time (ms)" COLLECTIONVARNAME="CollectionOfSQLServerLocksAverageWaitTimems" EXPRESSIONPATH="\SQLServer:Locks(*)\Average Wait Time (ms)" TRENDVARNAME="TrendSQLServerLocksAverageWaitTimems" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Locks(*)\Average Wait Time (ms)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Locks(*)\Average Wait Time (ms)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Locks(*)\Average Wait Time (ms)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Locks Average Wait Time (ms)</B>
<BR>
The average amount of wait time (milliseconds) for each lock request that resulted in a wait. This wait could indicate excessive blocking that can be verified by querying sys.dm_os_waiting_tasks. Compare this counter to "Lock Waits/sec" and look for trends.
<BR>
<B>Threshold</B><BR>
<B>Yellow</B> Greater than >500 Average Wait Time. <BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Worktables From Cache Ratio" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\SQLServer:Access Methods\Worktables From Cache Ratio" ID="2ae48638-5885-4af5-8220-42abfeab7c65" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Worktables From Cache Ratio" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsWorktablesFromCacheRatio" EXPRESSIONPATH="\SQLServer:Access Methods\Worktables From Cache Ratio" TRENDVARNAME="TrendSQLServerAccessMethodsWorktablesFromCacheRatio" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Worktables From Cache Ratio" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Access Methods\Worktables From Cache Ratio" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Worktables From Cache Ratio" CHARTLABELS="instance" />
    <THRESHOLD NAME="Less than 90% Worktables from Cache Ratio" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerAccessMethodsWorktablesFromCacheRatio -Operator 'lt' -Threshold 90]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>\SQLServer:Access Methods Worktables From Cache Ratio</B>
<BR>
<BR><B>Description:</B> Percentage of work tables created where the initial two pages of the work table were not allocated but were immediately available from the work table cache. 

In SQL Server 2005 worktable caching was improved. When a query execution plan is cached, the work tables needed by the plan are not dropped across multiple executions of the plan but merely truncated. In addition, the first nine pages for the work table are kept. In SQL Server 2000, the work tables used during query plan execution are dropped. Because the work table is cached, the next execution of the query is faster. When the system is low on memory, the execution plan may be removed from the cache and the associated work tables dropped as well. Both SQL Server 2000 and SQL Server 2005 use a small global pool of pre-allocated pages and extents that make the initial creation of work tables faster.
<BR><BR>
<B>Note:</B> When a work table is dropped, two pages may remain allocated and they are returned to the work table cache. A value less than 90% may indicate insufficient memory, since execution plans are being dropped, or may indicate, on 32-bit systems, the need for an upgrade to a 64-bit system.

<BR><BR><B>Threshold:</B>
<BR>Yellow: Less than 90% Worktables from Cache Ratio. This will need to be baselined for accuracy.

<BR><B>Reference:</B><BR>
<B>SQL Server, Access Methods Object</B>
http://msdn.microsoft.com/en-us/library/ms177426(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Access Methods Table Lock Escalations/sec" ENABLED="True" CATEGORY="SQLServer:Access Methods" PRIMARYDATASOURCE="\SQLServer:Access Methods\Table Lock Escalations/sec" ID="56da55da-22ee-4686-897c-74403b884e70" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Access Methods\Table Lock Escalations/sec" COLLECTIONVARNAME="CollectionOfSQLServerAccessMethodsTableLockEscalationssec" EXPRESSIONPATH="\SQLServer:Access Methods\Table Lock Escalations/sec" TRENDVARNAME="TrendSQLServerAccessMethodsTableLockEscalationssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Access Methods\Table Lock Escalations/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Access Methods\Table Lock Escalations/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Access Methods\Table Lock Escalations/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Experimental - Measuring an Increasing Trend of Table Lock Escalations (500)" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerAccessMethodsTableLockEscalationssec -Operator 'gt' -Threshold 500 -IsTrendOnly $True 

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Access Methods Table Lock Escalations/sec</B>
<BR><B>Description:</B>
The number of times locks on a table were escalated from page- or row-level to table-level. Frequent or even occasional spiking in this value may indicate poorly coded transactions.
<BR>

<B>Lock Escalation Thresholds</B>
<BR>
Lock escalation is triggered when lock escalation is not disabled on the table by using the ALTER TABLE SET LOCK_ESCALATION option, and when either of the following conditions exists: 
<UL>
  <LI>A single Transact-SQL statement acquires at least 5,000 locks on a single nonpartitioned table or index.</IL>
  <LI>A single Transact-SQL statement acquires at least 5,000 locks on a single partition of a partitioned table and the ALTER TABLE SET LOCK_ESCALATION option is set to AUTO.</IL>
  <LI>The number of locks in an instance of the Database Engine exceeds memory or configuration thresholds.</IL>
</UL>
If locks cannot be escalated because of lock conflicts, the Database Engine periodically triggers lock escalation at every 1,250 new locks acquired.
<BR>
<B>Next Steps</B>
<BR><B>Reducing Locking and Escalation</B><BR> 
In most cases, the Database Engine delivers the best performance when operating with its default settings for locking and lock escalation. If an instance of the Database Engine generates a lot of locks and is seeing frequent lock escalations, consider reducing the amount of locking by: 
<BR><BR>Using an isolation level that does not generate shared locks for read operations.
<UL>
<LI>READ COMMITTED isolation level when the READ_COMMITTED_SNAPSHOT database option is ON.</LI>
<LI>SNAPSHOT isolation level.</LI>
<LI>READ UNCOMMITTED isolation level. This can only be used for systems that can operate with dirty reads.</LI>
</UL>
<B>Note:</B> Changing the isolation level affects all tables on the instance of the Database Engine.
<UL>
<LI>Using the PAGLOCK or TABLOCK table hints to have the Database Engine use page, heap, or index locks instead of row locks. Using this option, however, increases the problems of users blocking other users attempting to access the same data and should not be used in systems with more than a few concurrent users.</LI>
<LI>For partitioned tables, use the LOCK_ESCALATION option of ALTER TABLEto escalate locks to the HoBT level instead of the table or to disable lock escalation.</LI>
</UL> 
You can also use trace flags 1211 and 1224 to disable all or some lock escalations. For more information, see Trace Flags (Transact-SQL). Also, monitor lock escalation by using the SQL Server Profiler Lock:Escalation event; and see Using SQL Server Profiler.
<BR>
<B>Reference:</B><BR>
<B>Lock Escalation (Database Engine)</B> - <BR>http://msdn.microsoft.com/en-us/library/ms184286(SQL.105).aspx

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Transactions\Free Space in tempdb  Free Space in tempdb (KB)" ENABLED="True" CATEGORY="SQLServer:Transactions" PRIMARYDATASOURCE="\SQLServer:Transactions\Free Space in tempdb (KB)" ID="7ad87fd4-0aa6-47c0-b55b-ad27de33fa8e" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Transactions\Free Space in tempdb (KB)" COLLECTIONVARNAME="CollectionOfSQLServerTransactionsFreeSpaceintempdbFreeSpaceintempdbKB" EXPRESSIONPATH="\SQLServer:Transactions\Free Space in tempdb (KB)" TRENDVARNAME="TrendSQLServerTransactionsFreeSpaceintempdbFreeSpaceintempdbKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Transactions\Free Space in tempdb (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Transactions\Free Space in tempdb (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Transactions\Free Space in tempdb (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Transactions\Free Space in tempdb  Free Space in tempdb (KB)</B>
<BR>
The free space in tempdb in KB.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Transactions Longest Transaction Running Time" ENABLED="True" CATEGORY="SQLServer:Transactions" PRIMARYDATASOURCE="\SQLServer:Transactions\Longest Transaction Running Time" ID="8aef429c-41d3-4f6f-a449-73b13532a6dd" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Transactions\Longest Transaction Running Time" COLLECTIONVARNAME="CollectionOfSQLServerTransactionsLongestTransactionRunningTime" EXPRESSIONPATH="\SQLServer:Transactions\Longest Transaction Running Time" TRENDVARNAME="TrendSQLServerTransactionsLongestTransactionRunningTime" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Transactions\Longest Transaction Running Time" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Transactions\Longest Transaction Running Time" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Transactions\Longest Transaction Running Time" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Transactions Longest Transaction Running Time</B>
<BR>
The longest running time of any transcation in seconds. This counter could indicate a long running statement pulling large amounts of data that normally takes a long time to execute or potentially a blocking condition.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Transactions NonSnapshot Version Transactions" ENABLED="True" CATEGORY="SQLServer:Transactions" PRIMARYDATASOURCE="\SQLServer:Transactions\NonSnapshot Version Transactions" ID="c1663db2-31b7-4b8b-bd7b-1d0983ed42d7" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Transactions\NonSnapshot Version Transactions" COLLECTIONVARNAME="CollectionOfSQLServerTransactionsNonSnapshotVersionTransactions" EXPRESSIONPATH="\SQLServer:Transactions\NonSnapshot Version Transactions" TRENDVARNAME="TrendSQLServerTransactionsNonSnapshotVersionTransactions" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Transactions\NonSnapshot Version Transactions" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Transactions\NonSnapshot Version Transactions" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Transactions\NonSnapshot Version Transactions" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Transactions NonSnapshot Version Transactions</B>
<BR>
The total number of active non-snapshot transactions that generate version records. These are all of the non-snapshot isolation versions such as triggers and online indexing.
<BR>
<B>Note:</B> The sum of Update Snapshot Transactions and NonSnapshot Version Transactions represents the total number of transactions that participate in version generation. The difference of Snapshot Transactions and Update Snapshot Transactions reports the number of read-only snapshot transactions. 
<BR>
<B>Reference:</B><BR>
<B>http://msdn.microsoft.com/en-us/library/ms176029(SQL.90).aspx</B>
http://msdn.microsoft.com/en-us/library/ms176029(SQL.90).aspx<BR>
<B>Managing TempDB in SQL Server: TempDB Basics (Version Store: Why do we need it?)</B><BR>
http://blogs.msdn.com/b/sqlserverstorageengine/archive/2008/12/22/managing-tempdb-in-sql-server-tempdb-basics-verison-store.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Transactions Snapshot Transactions" ENABLED="True" CATEGORY="SQLServer:Transactions" PRIMARYDATASOURCE="\SQLServer:Transactions\Snapshot Transactions" ID="57ab42a2-3af6-4a66-adb1-b8800f4bdeb8" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Transactions\Snapshot Transactions" COLLECTIONVARNAME="CollectionOfSQLServerTransactionsSnapshotTransactions" EXPRESSIONPATH="\SQLServer:Transactions\Snapshot Transactions" TRENDVARNAME="TrendSQLServerTransactionsSnapshotTransactions" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Transactions\Snapshot Transactions" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Transactions\Snapshot Transactions" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Transactions\Snapshot Transactions" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Transactions Snapshot Transactions</B>
<BR>
The total number of active snapshot transactions.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Transactions\Version Cleanup rate  Version Cleanup rate (KB/s)" ENABLED="True" CATEGORY="SQLServer:Transactions" PRIMARYDATASOURCE="\SQLServer:Transactions\Version Cleanup rate (KB/s)" ID="1b277ac8-2dc0-48da-9d0a-c4b7c4d25eb7" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Transactions\Version Cleanup rate (KB/s)" COLLECTIONVARNAME="CollectionOfSQLServerTransactionsVersionCleanuprateVersionCleanuprateKBs" EXPRESSIONPATH="\SQLServer:Transactions\Version Cleanup rate (KB/s)" TRENDVARNAME="TrendSQLServerTransactionsVersionCleanuprateVersionCleanuprateKBs" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Transactions\Version Cleanup rate (KB/s)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Transactions\Version Cleanup rate (KB/s)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Transactions\Version Cleanup rate (KB/s)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Transactions\Version Cleanup rate  Version Cleanup rate (KB/s)</B><BR>
<B>Description</B>

The version cleanup rate in KB per seconds.<BR>

Monitors the version cleanup rate in KBps in all version stores. If the version cleanup rate is lower than the version generation rate, the version store will use more and more space in tempdb. However, if the version cleanup rate is 0 but the version generation rate is not, there is probably a long-running transaction that is preventing the version store cleanup.
<BR>
Row versions are shared across sessions. The creator of the row version has no control over when the row version can be reclaimed. You will need to find and then possibly stop the longest-running transaction that is preventing the row version cleanup.
<BR>The following query returns the top two longest-running transactions that depend on the versions in the version store:
<BR> <B>
select top 2 <BR>
    transaction_id, <BR> 
    transaction_sequence_num, <BR> 
    elapsed_time_seconds <BR>
from sys.dm_tran_active_snapshot_database_transactions <BR>
order by elapsed_time_seconds DESC </B><BR>
<BR>
<B>Reference</B><BR>

<B>Row Versioning Resource Usage</B><BR>
http://msdn.microsoft.com/en-us/library/ms175492.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Transactions\Version Generation rate  Version Generation rate (KB/s)" ENABLED="True" CATEGORY="SQLServer:Transactions" PRIMARYDATASOURCE="\SQLServer:Transactions\Version Generation rate (KB/s)" ID="56cc0dfa-47e6-44c6-b003-29fde9b5bdec" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Transactions\Version Generation rate (KB/s)" COLLECTIONVARNAME="CollectionOfSQLServerTransactionsVersionGenerationrateVersionGenerationrateKBs" EXPRESSIONPATH="\SQLServer:Transactions\Version Generation rate (KB/s)" TRENDVARNAME="TrendSQLServerTransactionsVersionGenerationrateVersionGenerationrateKBs" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Transactions\Version Generation rate (KB/s)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Transactions\Version Generation rate (KB/s)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Transactions\Version Generation rate (KB/s)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:Transactions\Version Generation rate  Version Generation rate (KB/s)</B>
<BR>
<B>Description:</B> The version generation rate in KB per seconds.

You can use the Version Generation Rate and Version Cleanup Rate counters to measure version store impact on TempDB. THe Version Generation Rate should not outpace the Cleanup Rate. Additionally, if your Version Cleanup Rate is 0, a long-running transaction could be preventing the version store cleanup. Incidentally, before generating an out-of-tempdb-space error, SQL Server 2008 makes a last-ditch attempt by forcing the version stores to shrink. During the shrink process, the longest-running transactions that have not yet generated any row versions are marked as victims. This frees up the version space used by them. Message 3967 is generated in the error log for each such victim transaction. If a transaction is marked as a victim, it can no longer read the row versions in the version store or create new ones. Message 3966 is generated and the transaction is rolled back when the victim transaction attempts to read row versions. If the shrink of the version store succeeds, more space is available in tempdb. Otherwise, tempdb runs out of space.

If TempDB fills and runs out of space, writes will continue, butversions will not and reads will fail.
<BR>
<B>Reference</B><BR>
<B>SQL Server, Transactions Object</B><BR>
http://technet.microsoft.com/en-us/library/ms189038.aspx]]></DESCRIPTION>
  </ANALYSIS>
  <QUESTION QUESTIONVARNAME="PLEHealth" DATATYPE="string" DEFAULTVALUE="1000">Enter the Page Life Expectancy value under Buffer Manager / Page Life Expectancy when the SQL Server instance is healthy (or idle)</QUESTION>
  <QUESTION QUESTIONVARNAME="OLTPvsOLAP" DATATYPE="boolean" DEFAULTVALUE="True">Is the instance used for OLTP (as opposed to OLAP)?</QUESTION>
  <ANALYSIS NAME="SQLServer:SQL Plan Re-Use Rate" ENABLED="True" CATEGORY="SQLServer:SQL Statistics" PRIMARYDATASOURCE="\SQLServer:SQL Statistics\Batch Requests/sec" ID="51d7bbce-24b4-4357-84a5-0115331aa3bf" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\Batch Requests/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsBatchRequestssec" EXPRESSIONPATH="\SQLServer:SQL Statistics\Batch Requests/sec" TRENDVARNAME="TrendSQLServerSQLStatisticsBatchRequestssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\Batch Requests/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SQL Statistics\SQL Compilations/sec" EXPRESSIONPATH="\SQLServer:SQL Statistics\SQL Compilations/sec" COLLECTIONVARNAME="CollectionOfSQLServerSQLStatisticsSQLCompilationssec" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SQL Statistics\SQL Compilations/sec" DATATYPE="integer" />
    <DATASOURCE TYPE="Generated" NAME="\PAL Generated(*)\SQL Plan Re-Use Rate" EXPRESSIONPATH="\PAL Generated(*)\SQL Plan Re-Use Rate" COLLECTIONVARNAME="CollectionOfPalGeneratedSqlCompilationsPlanReUseRate" DATATYPE="Round3">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedSqlCompilationsPlanReUseRate = @{}
          For ($a=0;$a -lt $CollectionOfSQLServerSQLStatisticsSQLCompilationssec.Count;$a++)
          {
            $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].CounterObject
            $sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec"          
            #// Match up the same named instance.
            $m = -1
            For ($b=0;$b -lt $CollectionOfSQLServerSQLStatisticsBatchRequestssec.Count;$b++)
            {
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec = ExtractSqlNamedInstanceFromCounterObjectPath -sCounterObjectPath $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterObject
              $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer = "$($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$b].CounterComputer)" + '/' + "$sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssec"
              If ($sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssecWithComputer -eq $sSqlInstanceNameForSQLServerSQLStatisticsBatchRequestssecWithComputer)
              {
                $m = $b
              }
            }
			If ($m -ge 0)
			{
				$blValues = New-Object System.Collections.ArrayList
				For ($v=0;$v -lt $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value.Count;$v++)
				{
				  If ((IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value[$v]) -and (IsGreaterThanZero $CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]))
				  {
					If (($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value[$v] -gt 1) -and ($CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v] -gt 1))
					{
					  [double]$iRatio = $(((([double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v]) - ([double]$CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].Value[$v])) / ([double]$CollectionOfSQLServerSQLStatisticsBatchRequestssec[$m].Value[$v])) * 100)
					  #// Artificially set min rate to 0 and max rate to 100 when less than 0% or exceeds 100% 
					  If ($iRatio -lt 0)
					  {
						$iRatio = 0
					  }
					  If ($iRatio -gt 100)
					  {
						$iRatio = 100
					  }
					}
					Else
					{
					  $iRatio = 0
					}
					[void] $blValues.Add($iRatio)
				  }
				  Else
				  {
					[void] $blValues.Add(0)
				  }
				}
				$sGeneratedInstanceName = "\\$($CollectionOfSQLServerSQLStatisticsSQLCompilationssec[$a].CounterComputer)\PAL Generated($($sSqlInstanceNameForSQLServerSQLStatisticsSQLCompilationssec))\SQL Plan Re-Use Rate"
				$CollectionOfPalGeneratedSqlCompilationsPlanReUseRate.Add($sGeneratedInstanceName,$blValues)
			}
		  }
        ]]></CODE>
    </DATASOURCE>
    <THRESHOLD NAME="Plan re-use rate less than 90% when OLTP or 50% if OLAP" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
          If ($($OLTPvsOLAP) -eq $True)
          {
            $VarMaxThreshold = 90
          }
          Else
          {
            $VarMaxThreshold = 50
          }
            StaticThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedSqlCompilationsPlanReUseRate -Operator 'le' -Threshold $VarMaxThreshold 
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\PAL Generated(*)\SQL Plan Re-Use Rate" ISTHRESHOLDSADDED="True" DATASOURCE="\PAL Generated(*)\SQL Plan Re-Use Rate" CHARTLABELS="instance" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          If ($($OLTPvsOLAP) -eq $True)
          {
            $VarMaxThreshold = 90
          }
          Else
          {
            $VarMaxThreshold = 50
          }
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPalGeneratedSqlCompilationsPlanReUseRate -MinThreshold 0.001 -MaxThreshold $VarMaxThreshold -IsOperatorGreaterThan $False -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>SQLServer:SQL Plan Re-Use Rate</B>
<BR>
Plan re-use is desirable for OLTP workloads because re-creating the same plan (for similar or identical transactions) is a waste of CPU resources. 
<BR>To compute the plan re-use rate, compare SQL Server SQL Statistics: batch requests/sec to SQL compilations/sec.
<BR>Special exception to the plan re-use rule is that zero (or trivial) cost plans will not be cached (not re-used) in SQL 2005 SP2 and above. 
<BR>Applications that use zero cost plans will have a lower plan re-use but this is not a performance issue, because it is cheaper to generate a new plan every time than to cache. 
<BR><B>Reference:</B>
<BR><B>Execution Plan Caching and Reuse</B>
<BR>http://msdn.microsoft.com/en-us/library/ms181055.aspx
<BR><B>Top SQL Server 2005 Performance Issues for OLTP Applications</B>
<BR>http://technet.microsoft.com/en-us/library/cc966401.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="ReportServer:Service Memory Pressure State" ENABLED="True" CATEGORY="ReportServer:Service" PRIMARYDATASOURCE="\ReportServer:Service\Memory Pressure State" ID="4d5c1bd0-da30-46b9-bf5d-96fd959057f3" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\ReportServer:Service\Memory Pressure State" COLLECTIONVARNAME="CollectionOfReportServerServiceMemoryPressureState" EXPRESSIONPATH="\ReportServer:Service\Memory Pressure State" TRENDVARNAME="TrendReportServerServiceMemoryPressureState" DATATYPE="integer" />
    <CHART CHARTTITLE="\ReportServer:Service\Memory Pressure State" ISTHRESHOLDSADDED="False" DATASOURCE="\ReportServer:Service\Memory Pressure State" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>ReportServer:Service Memory Pressure State</B>
<BR>
A number from 1-5 indicating the current memory state of the server.
<BR> 
<UL>
<LI>1:No pressure</LI>
<LI>2:Low Pressure</LI>
<LI>3:Medium Pressure</LI>
<LI>4:High Pressure</LI>
<LI>5:Exceeded Pressure</LI>
<BR>
<B>Performance Counters for the ReportServer:Service Performance Object</B>
<BR>http://technet.microsoft.com/en-us/library/cc627471(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="ReportServer:Service Memory Shrink Notifications/sec" ENABLED="True" CATEGORY="ReportServer:Service" PRIMARYDATASOURCE="\ReportServer:Service\Memory Shrink Notifications/sec" ID="3e7624d3-4ce5-4428-be29-0cff88829fe2" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\ReportServer:Service\Memory Shrink Notifications/sec" COLLECTIONVARNAME="CollectionOfReportServerServiceMemoryShrinkNotificationssec" EXPRESSIONPATH="\ReportServer:Service\Memory Shrink Notifications/sec" TRENDVARNAME="TrendReportServerServiceMemoryShrinkNotificationssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\ReportServer:Service\Memory Shrink Notifications/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\ReportServer:Service\Memory Shrink Notifications/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>ReportServer:Service Memory Shrink Notifications/sec</B>
<BR>
Number of shrink notifications the server issued in the last second. Indicates how often the server believes it is under memory pressure.
<BR>
<B>Performance Counters for the ReportServer:Service Performance Object</B>
<BR>http://technet.microsoft.com/en-us/library/cc627471(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="ReportServer:Service Memory Shrink Amount" ENABLED="True" CATEGORY="ReportServer:Service" PRIMARYDATASOURCE="\ReportServer:Service\Memory Shrink Amount" ID="ad329954-890e-4346-b3cf-0262bd01ee8d" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\ReportServer:Service\Memory Shrink Amount" COLLECTIONVARNAME="CollectionOfReportServerServiceMemoryShrinkAmount" EXPRESSIONPATH="\ReportServer:Service\Memory Shrink Amount" TRENDVARNAME="TrendReportServerServiceMemoryShrinkAmount" DATATYPE="integer" />
    <CHART CHARTTITLE="\ReportServer:Service\Memory Shrink Amount" ISTHRESHOLDSADDED="False" DATASOURCE="\ReportServer:Service\Memory Shrink Amount" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>ReportServer:Service Memory Shrink Amount</B>
<BR>
Number of bytes the server requested to shrink.
<BR>
<B>Performance Counters for the ReportServer:Service Performance Object</B>
<BR>http://technet.microsoft.com/en-us/library/cc627471(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Node Page life expectancy" ENABLED="True" CATEGORY="SQLServer:Buffer Node" PRIMARYDATASOURCE="\SQLServer:Buffer Node(*)\Page life expectancy" ID="f291a061-ff98-43f2-9f2d-ebcaa6eb516c" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Node(*)\Page life expectancy" COLLECTIONVARNAME="CollectionOfSQLServerBufferNodePagelifeexpectancy" EXPRESSIONPATH="\SQLServer:Buffer Node(*)\Page life expectancy" TRENDVARNAME="TrendSQLServerBufferNodePagelifeexpectancy" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Node(*)\Page life expectancy" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Node(*)\Page life expectancy" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Node(*)\Page life expectancy" CHARTLABELS="instance" />
    <THRESHOLD NAME="Less than 30% (300 seconds by default) of the Page Life Expectancy Baseline" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[$ThirtyPercentOfPLEHealth1 = $([Int]$PLEHealth) * 0.30
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferNodePagelifeexpectancy -Operator 'lt' -Threshold $ThirtyPercentOfPLEHealth1]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Decreasing Trend of 30% PLEHealth (300 seconds default) per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[$ThirtyPercentOfPLEHealth1 = -$([Int]$PLEHealth) * 0.30
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferNodePagelifeexpectancy -Operator 'lt' -Threshold $ThirtyPercentOfPLEHealth1 -IsTrendOnly $True]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 70% (700 seconds by default) of the Page Life Expectancy Baseline2" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[$SeventyPercentOfPLEHealth1 = $([Int]$PLEHealth) * 0.70
StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferNodePagelifeexpectancy -Operator 'lt' -Threshold $SeventyPercentOfPLEHealth1

]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Buffer Node Page life expectancy</B>
<BR>
Number of seconds a page will stay in the buffer pool without references.
<BR>
When we are using NUMA architecture which is becoming more common you will see memory nodes. We have one memory node per NUMA node and this is used to allocate memory in a particular node. This is visible in the SQL Server Buffer Node perfmon group. If you want to make sure you are performing local memory access versus foreign memory access we need to pay attention to where the memory is being allocated which can be tracked via sys.dm_os_memory_nodes. 
<BR>
If we do not have enough memory in a particular NUMA node, we will perform a foreign access if we have to, but SQL Server tries to avoid this. 
<BR>
<B>Note:</B> See "SQLServer_Buffer Manager Page Life Expectancy"  for details.
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Buffer Node Foreign pages" ENABLED="True" CATEGORY="SQLServer:Buffer Node" PRIMARYDATASOURCE="\SQLServer:Buffer Node(*)\Foreign pages" ID="dd3cb0be-28ae-4765-a890-b05050fb6154" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Buffer Node(*)\Foreign pages" COLLECTIONVARNAME="CollectionOfSQLServerBufferNodeForeignpages" EXPRESSIONPATH="\SQLServer:Buffer Node(*)\Foreign pages" TRENDVARNAME="TrendSQLServerBufferNodeForeignpages" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Buffer Node(*)\Foreign pages" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Buffer Node(*)\Foreign pages" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Buffer Node(*)\Foreign pages" CHARTLABELS="instance" />
    <THRESHOLD NAME="Foreign Pages is Greater Than 0" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerBufferNodeForeignpages -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:Buffer Node Foreign pages</B>
<BR>
Number of pages which are not from NUMA-local memory.
<BR>
When we are using NUMA architecture which is becoming more common you will see memory nodes. We have one memory node per NUMA node and this is used to allocate memory in a particular node. This is visible in the SQL Server Buffer Node perfmon group. If you want to make sure you are performing local memory access versus foreign memory access we need to pay attention to where the memory is being allocated which can be tracked via sys.dm_os_memory_nodes. 

If we do not have enough memory in a particular NUMA node, we will perform a foreign access if we have to, but SQL Server tries to avoid this. 
<BR>
<B>Reference:</B>
http://msdn.microsoft.com/en-us/library/ms345597(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SSIS Pipeline 10.0 Buffer memory" ENABLED="True" CATEGORY="SQLServer:SSIS Pipeline 10.0" PRIMARYDATASOURCE="\SQLServer:SSIS Pipeline 10.0\Buffer memory" ID="1e5d9baa-9827-404d-8c30-a8c410dc13f3" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SSIS Pipeline 10.0\Buffer memory" COLLECTIONVARNAME="CollectionOfSQLServerSSISPipeline100Buffermemory" EXPRESSIONPATH="\SQLServer:SSIS Pipeline 10.0\Buffer memory" TRENDVARNAME="TrendSQLServerSSISPipeline100Buffermemory" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SSIS Pipeline 10.0\Buffer memory" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SSIS Pipeline 10.0\Buffer memory" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SSIS Pipeline 10.0\Buffer memory" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SSIS Pipeline 10.0 Buffer memory</B>
<BR>
The amount of memory that is in use. This may include both physical and virtual memory. When this number is larger than the amount of physical memory, the Buffers Spooled count rises as an indication that memory swapping is increasing. Increased memory swapping slows performance of the data flow engine. 
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SSIS Pipeline 10.0 Buffers spooled" ENABLED="True" CATEGORY="SQLServer:SSIS Pipeline 10.0" PRIMARYDATASOURCE="\SQLServer:SSIS Pipeline 10.0\Buffers spooled" ID="8d2b208b-9599-42ce-8662-ada212145370" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SSIS Pipeline 10.0\Buffers spooled" COLLECTIONVARNAME="CollectionOfSQLServerSSISPipeline100Buffersspooled" EXPRESSIONPATH="\SQLServer:SSIS Pipeline 10.0\Buffers spooled" TRENDVARNAME="TrendSQLServerSSISPipeline100Buffersspooled" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SSIS Pipeline 10.0\Buffers spooled" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SSIS Pipeline 10.0\Buffers spooled" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SSIS Pipeline 10.0\Buffers spooled" CHARTLABELS="instance" />
    <THRESHOLD NAME="Buffer Spooled is Greater than 0" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfSQLServerSSISPipeline100Buffersspooled -Operator 'gt' -Threshold 0]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[<B>SQLServer:SSIS Pipeline 10.0 Buffers spooled</B>
<BR>
The number of buffers spooled to disk.

Buffers spooled has an initial value of 0. When it goes above 0, it indicates that the engine has started memory swapping. 

In this case, it is recommended to set Data Flow Task properties BLOBTempStoragePath and BufferTempStoragePath appropriately for maximal I/O bandwidth. 


<BR>
<B>Reference:</B>
<BR>http://msdn.microsoft.com/en-us/library/ms137622.aspx
<BR>http://msdn.microsoft.com/en-us/library/dd795224(v=SQL.100).aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SSIS Pipeline 10.0 Flat buffers in use" ENABLED="True" CATEGORY="SQLServer:SSIS Pipeline 10.0" PRIMARYDATASOURCE="\SQLServer:SSIS Pipeline 10.0\Flat buffers in use" ID="6c82d379-c985-4c99-a78a-83a1f18755fb" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SSIS Pipeline 10.0\Flat buffers in use" COLLECTIONVARNAME="CollectionOfSQLServerSSISPipeline100Flatbuffersinuse" EXPRESSIONPATH="\SQLServer:SSIS Pipeline 10.0\Flat buffers in use" TRENDVARNAME="TrendSQLServerSSISPipeline100Flatbuffersinuse" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SSIS Pipeline 10.0\Flat buffers in use" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SSIS Pipeline 10.0\Flat buffers in use" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SSIS Pipeline 10.0\Flat buffers in use" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SSIS Pipeline 10.0 Flat buffers in use</B>
<BR>The number of flat memory buffers in use throughout the pipeline.
<BR>
Buffers in use, Flat buffers in use and Private buffers in use are useful to discover leaks. During package execution time, you will see these counters fluctuating. But once the package finishes execution, their values should return to the same value as what they were before the execution. Otherwise, buffers are leaked. In occasions like that, it is recommended to contact Microsoft PSS. 

Rows read and Rows written show how many rows the entire Data Flow has processed. They give you an overall idea about the execution progress. 
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SSIS Pipeline 10.0 Buffers in use" ENABLED="True" CATEGORY="SQLServer:SSIS Pipeline 10.0" PRIMARYDATASOURCE="\SQLServer:SSIS Pipeline 10.0\Buffers in use" ID="72000a72-2bba-414e-8fe2-8b0027f33d5d" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SSIS Pipeline 10.0\Buffers in use" COLLECTIONVARNAME="CollectionOfSQLServerSSISPipeline100Buffersinuse" EXPRESSIONPATH="\SQLServer:SSIS Pipeline 10.0\Buffers in use" TRENDVARNAME="TrendSQLServerSSISPipeline100Buffersinuse" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SSIS Pipeline 10.0\Buffers in use" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SSIS Pipeline 10.0\Buffers in use" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SSIS Pipeline 10.0\Buffers in use" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SSIS Pipeline 10.0 Buffers in use</B>
<BR>
The number of pipeline buffers in use throughout the pipeline.
<BR>
Buffers in use, Flat buffers in use and Private buffers in use are useful to discover leaks. During package execution time, you will see these counters fluctuating. But once the package finishes execution, their values should return to the same value as what they were before the execution. Otherwise, buffers are leaked. In occasions like that, it is recommended to contact Microsoft PSS. 

Rows read and Rows written show how many rows the entire Data Flow has processed. They give you an overall idea about the execution progress. 
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:SSIS Pipeline 10.0 Private buffers in use" ENABLED="True" CATEGORY="SQLServer:SSIS Pipeline 10.0" PRIMARYDATASOURCE="\SQLServer:SSIS Pipeline 10.0\Private buffers in use" ID="459c7cb8-c2b6-4641-ae91-99aab2b3d2f9" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SSIS Pipeline 10.0 Private buffers in use" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:SSIS Pipeline 10.0\Private buffers in use" COLLECTIONVARNAME="CollectionOfSQLServerSSISPipeline100Privatebuffersinuse" EXPRESSIONPATH="\SQLServer:SSIS Pipeline 10.0\Private buffers in use" TRENDVARNAME="TrendSQLServerSSISPipeline100Privatebuffersinuse" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:SSIS Pipeline 10.0\Private buffers in use" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:SSIS Pipeline 10.0\Private buffers in use" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:SSIS Pipeline 10.0\Private buffers in use" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLServer:SSIS Pipeline 10.0 Private buffers in use</B>
<BR>
The number of private transformation buffers in use throughout the pipeline.
<BR>
Buffers in use, Flat buffers in use and Private buffers in use are useful to discover leaks. During package execution time, you will see these counters fluctuating. But once the package finishes execution, their values should return to the same value as what they were before the execution. Otherwise, buffers are leaked. In occasions like that, it is recommended to contact Microsoft PSS. 

Rows read and Rows written show how many rows the entire Data Flow has processed. They give you an overall idea about the execution progress. 
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLServer:Resource Pool Stats Max memory (KB)" ENABLED="True" CATEGORY="SQLServer:Resource Pool Stats" PRIMARYDATASOURCE="\SQLServer:Resource Pool Stats(*)\Max memory (KB)" ID="6d23a90d-3d6f-49c9-b0cd-ac47e62d9b2b" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLServer:Resource Pool Stats(*)\Max memory (KB)" COLLECTIONVARNAME="CollectionOfSQLServerResourcePoolStatsMaxmemoryKB" EXPRESSIONPATH="\SQLServer:Resource Pool Stats(*)\Max memory (KB)" TRENDVARNAME="TrendSQLServerResourcePoolStatsMaxmemoryKB" ISCOUNTEROBJECTREGULAREXPRESSION="True" ISCOUNTERNAMEREGULAREXPRESSION="False" ISCOUNTERINSTANCEREGULAREXPRESSION="False" REGULAREXPRESSIONCOUNTERPATH="\(MSSQL|SQLServer).*:Resource Pool Stats(*)\Max memory (KB)" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLServer:Resource Pool Stats(*)\Max memory (KB)" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLServer:Resource Pool Stats(*)\Max memory (KB)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Maximum amount of memory in kilobytes the resource pool can have based on the settings and server state.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSRS 2008 R2 Web Service Report Requests" ENABLED="True" CATEGORY="MSRS 2008 R2 Web Service" PRIMARYDATASOURCE="\MSRS 2008 R2 Web Service\Report Requests" ID="1300c19d-bf55-43ce-a134-b18341c53194" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\MSRS 2008 R2 Web Service\Report Requests" COLLECTIONVARNAME="CollectionOfMSRS2008R2WebServiceReportRequests" EXPRESSIONPATH="\MSRS 2008 R2 Web Service\Report Requests" TRENDVARNAME="TrendMSRS2008R2WebServiceReportRequests" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSRS 2008 R2 Web Service\Report Requests" ISTHRESHOLDSADDED="False" DATASOURCE="\MSRS 2008 R2 Web Service\Report Requests" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>MSRS 2008 R2 Web Service Report Requests</B>
<BR>
Number of reports that are currently active and being handled by the report server. Use this counter to evaluate caching strategy. There might be significantly more requests than reports generated.
<BR>
<B>Performance Counters for the MSRS 2008 R2 Windows Service Performance Object </B>
<BR>
http://technet.microsoft.com/en-US/library/ms157314(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSRS 2008 R2 Web Service Cache Misses/Sec" ENABLED="True" CATEGORY="MSRS 2008 R2 Web Service" PRIMARYDATASOURCE="\MSRS 2008 R2 Web Service\Cache Misses/Sec" ID="39d66636-29c8-4de0-a46d-42ea9ec4773e" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\MSRS 2008 R2 Web Service\Cache Misses/Sec" COLLECTIONVARNAME="CollectionOfMSRS2008R2WebServiceCacheMissesSec" EXPRESSIONPATH="\MSRS 2008 R2 Web Service\Cache Misses/Sec" TRENDVARNAME="TrendMSRS2008R2WebServiceCacheMissesSec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSRS 2008 R2 Web Service\Cache Misses/Sec" ISTHRESHOLDSADDED="False" DATASOURCE="\MSRS 2008 R2 Web Service\Cache Misses/Sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>MSRS 2008 R2 Web Service Cache Misses/Sec</B>
<BR>Number of requests per second that failed to return a report from cache. Use this counter to find out whether the resources used for caching (disk or memory) are sufficient.
<BR>
<B>Performance Counters for the MSRS 2008 R2 Windows Service Performance Object </B>
<BR>
http://technet.microsoft.com/en-US/library/ms157314(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSRS 2008 R2 Web Service Total Memory Cache Misses" ENABLED="True" CATEGORY="MSRS 2008 R2 Web Service" PRIMARYDATASOURCE="\MSRS 2008 R2 Web Service\Total Memory Cache Misses" ID="78680d92-2b3c-4622-b396-740b96896e04" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\MSRS 2008 R2 Web Service\Total Memory Cache Misses" COLLECTIONVARNAME="CollectionOfMSRS2008R2WebServiceTotalMemoryCacheMisses" EXPRESSIONPATH="\MSRS 2008 R2 Web Service\Total Memory Cache Misses" TRENDVARNAME="TrendMSRS2008R2WebServiceTotalMemoryCacheMisses" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSRS 2008 R2 Web Service\Total Memory Cache Misses" ISTHRESHOLDSADDED="False" DATASOURCE="\MSRS 2008 R2 Web Service\Total Memory Cache Misses" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>MSRS 2008 R2 Web Service Total Memory Cache Misses</B>
<BR>
Total number of cache misses against the in-memory cache after the service started. This counter resets when the application domain recycles.
<BR>
<B>Performance Counters for the MSRS 2008 R2 Windows Service Performance Object </B>
<BR>
http://technet.microsoft.com/en-US/library/ms157314(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSRS 2008 R2 Web Service Total Requests" ENABLED="True" CATEGORY="MSRS 2008 R2 Web Service" PRIMARYDATASOURCE="\MSRS 2008 R2 Web Service\Total Requests" ID="a6d0ba13-77f6-4f93-becf-48e6d93121e0" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\MSRS 2008 R2 Web Service\Total Requests" COLLECTIONVARNAME="CollectionOfMSRS2008R2WebServiceTotalRequests" EXPRESSIONPATH="\MSRS 2008 R2 Web Service\Total Requests" TRENDVARNAME="TrendMSRS2008R2WebServiceTotalRequests" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSRS 2008 R2 Web Service\Total Requests" ISTHRESHOLDSADDED="False" DATASOURCE="\MSRS 2008 R2 Web Service\Total Requests" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>MSRS 2008 R2 Web Service Total Requests</B>
<BR>
Total number of reports that ran successfully after the service started. This counter resets when the application domain recycles.
<BR>
<B>Performance Counters for the MSRS 2008 R2 Windows Service Performance Object </B>
<BR>
http://technet.microsoft.com/en-US/library/ms157314(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="ReportServer:Service Errors Total" ENABLED="True" CATEGORY="ReportServer:Service" PRIMARYDATASOURCE="\ReportServer:Service\Errors Total" ID="6947aa69-df40-4043-9250-6ae823630235" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\ReportServer:Service\Errors Total" COLLECTIONVARNAME="CollectionOfReportServerServiceErrorsTotal" EXPRESSIONPATH="\ReportServer:Service\Errors Total" TRENDVARNAME="TrendReportServerServiceErrorsTotal" DATATYPE="integer" />
    <CHART CHARTTITLE="\ReportServer:Service\Errors Total" ISTHRESHOLDSADDED="False" DATASOURCE="\ReportServer:Service\Errors Total" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>ReportServer:Service Errors Total</B>
<BR>
The total number of errors that occur during the processing of HTTP requests. These errors include HTTP status codes in the 400s and 500s.
<BR>
<B>Performance Counters for the ReportServer:Service Performance Object</B>
<BR>http://technet.microsoft.com/en-us/library/cc627471(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="ReportServer:Service Errors/sec" ENABLED="True" CATEGORY="ReportServer:Service" PRIMARYDATASOURCE="\ReportServer:Service\Errors/sec" ID="a3108e2c-c719-4a7c-90d6-cbf9f51b5292" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\ReportServer:Service\Errors/sec" COLLECTIONVARNAME="CollectionOfReportServerServiceErrorssec" EXPRESSIONPATH="\ReportServer:Service\Errors/sec" TRENDVARNAME="TrendReportServerServiceErrorssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\ReportServer:Service\Errors/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\ReportServer:Service\Errors/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>ReportServer:Service Errors/sec</B>
<BR>
The total number of errors that occur per second during the processing of HTTP requests. These errors include HTTP status codes in the 400s and 500s.
<BR>
<B>Performance Counters for the ReportServer:Service Performance Object</B>
<BR>http://technet.microsoft.com/en-us/library/cc627471(v=sql.105).aspx]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLAgent:Jobs Failed jobs" ENABLED="True" CATEGORY="SQLAgent:Jobs" PRIMARYDATASOURCE="\SQLAgent:Jobs\Failed jobs" ID="78701c98-ded8-4615-ac48-acb3053f19c2" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLAgent:Jobs\Failed jobs" COLLECTIONVARNAME="CollectionOfSQLAgentJobsFailedjobs" EXPRESSIONPATH="\SQLAgent:Jobs\Failed jobs" TRENDVARNAME="TrendSQLAgentJobsFailedjobs" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLAgent:Jobs\Failed jobs" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLAgent:Jobs\Failed jobs" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLAgent:Jobs Failed jobs</B>
<BR>
The number of Jobs that have failed to complete successfully for any reason since the last SQL Server Agent restart.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLAgent:Jobs Active jobs" ENABLED="True" CATEGORY="SQLAgent:Jobs" PRIMARYDATASOURCE="\SQLAgent:Jobs\Active jobs" ID="4d20eac4-a5e0-420f-8863-24364547b7b7" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLAgent:Jobs\Active jobs" COLLECTIONVARNAME="CollectionOfSQLAgentJobsActivejobs" EXPRESSIONPATH="\SQLAgent:Jobs\Active jobs" TRENDVARNAME="TrendSQLAgentJobsActivejobs" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLAgent:Jobs\Active jobs" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLAgent:Jobs\Active jobs" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLAgent:Jobs Active jobs</B>
<BR>
Number of running jobs. This counter can be used to find out if the current load on the system is potentially being driven from SQL Server Agent execution.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLAgent:Jobs Job success rate" ENABLED="True" CATEGORY="SQLAgent:Jobs" PRIMARYDATASOURCE="\SQLAgent:Jobs\Job success rate" ID="37abdb47-d97f-4381-8407-b9957fe65cc2" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLAgent:Jobs\Job success rate" COLLECTIONVARNAME="CollectionOfSQLAgentJobsJobsuccessrate" EXPRESSIONPATH="\SQLAgent:Jobs\Job success rate" TRENDVARNAME="TrendSQLAgentJobsJobsuccessrate" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLAgent:Jobs\Job success rate" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLAgent:Jobs\Job success rate" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLAgent:Jobs Job success rate</B>
<BR>
Percentage of successful jobs from the total number of executed jobs.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLAgent:Jobs Successful jobs" ENABLED="True" CATEGORY="SQLAgent:Jobs" PRIMARYDATASOURCE="\SQLAgent:Jobs\Successful jobs" ID="707f89c6-b74f-4314-a502-eefd0f23755b" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLAgent:Jobs\Successful jobs" COLLECTIONVARNAME="CollectionOfSQLAgentJobsSuccessfuljobs" EXPRESSIONPATH="\SQLAgent:Jobs\Successful jobs" TRENDVARNAME="TrendSQLAgentJobsSuccessfuljobs" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLAgent:Jobs\Successful jobs" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLAgent:Jobs\Successful jobs" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLAgent:Jobs Successful jobs</B>
<BR>
The number of Jobs that have successfully completed since the last SQL Server Agent restart.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLAgent:JobSteps Active steps" ENABLED="True" CATEGORY="SQLAgent:JobSteps" PRIMARYDATASOURCE="\SQLAgent:JobSteps\Active steps" ID="bacb8c6b-aaeb-4488-826f-b5a4351690c0" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLAgent:JobSteps\Active steps" COLLECTIONVARNAME="CollectionOfSQLAgentJobStepsActivesteps" EXPRESSIONPATH="\SQLAgent:JobSteps\Active steps" TRENDVARNAME="TrendSQLAgentJobStepsActivesteps" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLAgent:JobSteps\Active steps" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLAgent:JobSteps\Active steps" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLAgent:JobSteps Active steps</B>
<BR>
Number of active steps.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="SQLAgent:JobSteps Total step retries" ENABLED="True" CATEGORY="SQLAgent:JobSteps" PRIMARYDATASOURCE="\SQLAgent:JobSteps\Total step retries" ID="a065c936-f0b5-4cfa-9c05-c22597957cf9" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\SQLAgent:JobSteps\Total step retries" COLLECTIONVARNAME="CollectionOfSQLAgentJobStepsTotalstepretries" EXPRESSIONPATH="\SQLAgent:JobSteps\Total step retries" TRENDVARNAME="TrendSQLAgentJobStepsTotalstepretries" DATATYPE="integer" />
    <CHART CHARTTITLE="\SQLAgent:JobSteps\Total step retries" ISTHRESHOLDSADDED="False" DATASOURCE="\SQLAgent:JobSteps\Total step retries" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>SQLAgent:JobSteps Total step retries</B>
<BR>
The total number of times any Job Step execution is retried since the last SQL Server restart.]]></DESCRIPTION>
  </ANALYSIS>
  <INHERITANCE FILEPATH="SystemOverview.xml" />
</PAL>